// Autogenerated with StateSmith 0.17.5+6ec341a3c93edf598f2ca7c31f61af85857928de.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// This file is autogenerated! Do not edit it directly. Instead, edit the companion .drawio
// file in draw.io and generate this file by running "ss.cli run -h" in the command line.

#include "ModeSm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
    

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(ModeSm* sm, ModeSm_StateId desired_state);

static void ROOT_enter(ModeSm* sm);

static void CALIBRATION_STATES_enter(ModeSm* sm);

static void CALIBRATION_STATES_exit(ModeSm* sm);

static void CALIBRATION_STATES_ExitPoint_done__transition(ModeSm* sm);

static void CALIBRATE_CW_PA_enter(ModeSm* sm);

static void CALIBRATE_CW_PA_exit(ModeSm* sm);

static void CALIBRATE_CW_PA_calibrate_exit(ModeSm* sm);

static void CALIBRATE_FREQUENCY_enter(ModeSm* sm);

static void CALIBRATE_FREQUENCY_exit(ModeSm* sm);

static void CALIBRATE_FREQUENCY_calibrate_exit(ModeSm* sm);

static void CALIBRATE_RX_IQ_enter(ModeSm* sm);

static void CALIBRATE_RX_IQ_exit(ModeSm* sm);

static void CALIBRATE_RX_IQ_calibrate_exit(ModeSm* sm);

static void CALIBRATE_SSB_PA_enter(ModeSm* sm);

static void CALIBRATE_SSB_PA_exit(ModeSm* sm);

static void CALIBRATE_SSB_PA_calibrate_exit(ModeSm* sm);

static void CALIBRATE_TX_IQ_MARK_enter(ModeSm* sm);

static void CALIBRATE_TX_IQ_MARK_exit(ModeSm* sm);

static void CALIBRATE_TX_IQ_MARK_ptt_released(ModeSm* sm);

static void CALIBRATE_TX_IQ_SPACE_enter(ModeSm* sm);

static void CALIBRATE_TX_IQ_SPACE_exit(ModeSm* sm);

static void CALIBRATE_TX_IQ_SPACE_calibrate_exit(ModeSm* sm);

static void CALIBRATE_TX_IQ_SPACE_ptt_pressed(ModeSm* sm);

static void NORMAL_STATES_enter(ModeSm* sm);

static void NORMAL_STATES_exit(ModeSm* sm);

static void NORMAL_STATES_calibrate_cw_pa(ModeSm* sm);

static void NORMAL_STATES_calibrate_frequency(ModeSm* sm);

static void NORMAL_STATES_calibrate_rx_iq(ModeSm* sm);

static void NORMAL_STATES_calibrate_ssb_pa(ModeSm* sm);

static void NORMAL_STATES_calibrate_tx_iq(ModeSm* sm);

static void NORMAL_STATES_InitialState_transition(ModeSm* sm);

static void CW_RECEIVE_enter(ModeSm* sm);

static void CW_RECEIVE_exit(ModeSm* sm);

static void CW_RECEIVE_dah_pressed(ModeSm* sm);

static void CW_RECEIVE_dit_pressed(ModeSm* sm);

static void CW_RECEIVE_do(ModeSm* sm);

static void CW_RECEIVE_key_pressed(ModeSm* sm);

static void CW_RECEIVE_to_ssb_mode(ModeSm* sm);

static void CW_TRANSMIT_DAH_MARK_enter(ModeSm* sm);

static void CW_TRANSMIT_DAH_MARK_exit(ModeSm* sm);

static void CW_TRANSMIT_DAH_MARK_do(ModeSm* sm);

static void CW_TRANSMIT_DIT_MARK_enter(ModeSm* sm);

static void CW_TRANSMIT_DIT_MARK_exit(ModeSm* sm);

static void CW_TRANSMIT_DIT_MARK_do(ModeSm* sm);

static void CW_TRANSMIT_KEYER_SPACE_enter(ModeSm* sm);

static void CW_TRANSMIT_KEYER_SPACE_exit(ModeSm* sm);

static void CW_TRANSMIT_KEYER_SPACE_do(ModeSm* sm);

static void CW_TRANSMIT_KEYER_WAIT_enter(ModeSm* sm);

static void CW_TRANSMIT_KEYER_WAIT_exit(ModeSm* sm);

static void CW_TRANSMIT_KEYER_WAIT_dah_pressed(ModeSm* sm);

static void CW_TRANSMIT_KEYER_WAIT_dit_pressed(ModeSm* sm);

static void CW_TRANSMIT_KEYER_WAIT_do(ModeSm* sm);

static void CW_TRANSMIT_MARK_enter(ModeSm* sm);

static void CW_TRANSMIT_MARK_exit(ModeSm* sm);

static void CW_TRANSMIT_MARK_key_released(ModeSm* sm);

static void CW_TRANSMIT_SPACE_enter(ModeSm* sm);

static void CW_TRANSMIT_SPACE_exit(ModeSm* sm);

static void CW_TRANSMIT_SPACE_do(ModeSm* sm);

static void CW_TRANSMIT_SPACE_key_pressed(ModeSm* sm);

static void SSB_RECEIVE_enter(ModeSm* sm);

static void SSB_RECEIVE_exit(ModeSm* sm);

static void SSB_RECEIVE_ptt_pressed(ModeSm* sm);

static void SSB_RECEIVE_to_cw_mode(ModeSm* sm);

static void SSB_TRANSMIT_enter(ModeSm* sm);

static void SSB_TRANSMIT_exit(ModeSm* sm);

static void SSB_TRANSMIT_ptt_released(ModeSm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void ModeSm_ctor(ModeSm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void ModeSm_start(ModeSm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(NORMAL_STATES)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `NORMAL_STATES`.
            NORMAL_STATES_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            NORMAL_STATES_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void ModeSm_dispatch_event(ModeSm* sm, ModeSm_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: ModeSm
        case ModeSm_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: CALIBRATION_STATES
        case ModeSm_StateId_CALIBRATION_STATES:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: CALIBRATE_CW_PA
        case ModeSm_StateId_CALIBRATE_CW_PA:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_EXIT: CALIBRATE_CW_PA_calibrate_exit(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_FREQUENCY
        case ModeSm_StateId_CALIBRATE_FREQUENCY:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_EXIT: CALIBRATE_FREQUENCY_calibrate_exit(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_RX_IQ
        case ModeSm_StateId_CALIBRATE_RX_IQ:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_EXIT: CALIBRATE_RX_IQ_calibrate_exit(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_SSB_PA
        case ModeSm_StateId_CALIBRATE_SSB_PA:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_EXIT: CALIBRATE_SSB_PA_calibrate_exit(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_TX_IQ_MARK
        case ModeSm_StateId_CALIBRATE_TX_IQ_MARK:
            switch (event_id)
            {
                case ModeSm_EventId_PTT_RELEASED: CALIBRATE_TX_IQ_MARK_ptt_released(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_TX_IQ_SPACE
        case ModeSm_StateId_CALIBRATE_TX_IQ_SPACE:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_EXIT: CALIBRATE_TX_IQ_SPACE_calibrate_exit(sm); break;
                case ModeSm_EventId_PTT_PRESSED: CALIBRATE_TX_IQ_SPACE_ptt_pressed(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: NORMAL_STATES
        case ModeSm_StateId_NORMAL_STATES:
            switch (event_id)
            {
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break;
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break;
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break;
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break;
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_RECEIVE
        case ModeSm_StateId_CW_RECEIVE:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_RECEIVE_do(sm); break;
                case ModeSm_EventId_TO_SSB_MODE: CW_RECEIVE_to_ssb_mode(sm); break;
                case ModeSm_EventId_KEY_PRESSED: CW_RECEIVE_key_pressed(sm); break;
                case ModeSm_EventId_DAH_PRESSED: CW_RECEIVE_dah_pressed(sm); break;
                case ModeSm_EventId_DIT_PRESSED: CW_RECEIVE_dit_pressed(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_DAH_MARK
        case ModeSm_StateId_CW_TRANSMIT_DAH_MARK:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_TRANSMIT_DAH_MARK_do(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_DIT_MARK
        case ModeSm_StateId_CW_TRANSMIT_DIT_MARK:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_TRANSMIT_DIT_MARK_do(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_KEYER_SPACE
        case ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_TRANSMIT_KEYER_SPACE_do(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_KEYER_WAIT
        case ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_TRANSMIT_KEYER_WAIT_do(sm); break;
                case ModeSm_EventId_DIT_PRESSED: CW_TRANSMIT_KEYER_WAIT_dit_pressed(sm); break;
                case ModeSm_EventId_DAH_PRESSED: CW_TRANSMIT_KEYER_WAIT_dah_pressed(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_MARK
        case ModeSm_StateId_CW_TRANSMIT_MARK:
            switch (event_id)
            {
                case ModeSm_EventId_KEY_RELEASED: CW_TRANSMIT_MARK_key_released(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CW_TRANSMIT_SPACE
        case ModeSm_StateId_CW_TRANSMIT_SPACE:
            switch (event_id)
            {
                case ModeSm_EventId_DO: CW_TRANSMIT_SPACE_do(sm); break;
                case ModeSm_EventId_KEY_PRESSED: CW_TRANSMIT_SPACE_key_pressed(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SSB_RECEIVE
        case ModeSm_StateId_SSB_RECEIVE:
            switch (event_id)
            {
                case ModeSm_EventId_TO_CW_MODE: SSB_RECEIVE_to_cw_mode(sm); break;
                case ModeSm_EventId_PTT_PRESSED: SSB_RECEIVE_ptt_pressed(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SSB_TRANSMIT
        case ModeSm_StateId_SSB_TRANSMIT:
            switch (event_id)
            {
                case ModeSm_EventId_PTT_RELEASED: SSB_TRANSMIT_ptt_released(sm); break;
                case ModeSm_EventId_CALIBRATE_FREQUENCY: NORMAL_STATES_calibrate_frequency(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_RX_IQ: NORMAL_STATES_calibrate_rx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_TX_IQ: NORMAL_STATES_calibrate_tx_iq(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_CW_PA: NORMAL_STATES_calibrate_cw_pa(sm); break; // First ancestor handler for this event
                case ModeSm_EventId_CALIBRATE_SSB_PA: NORMAL_STATES_calibrate_ssb_pa(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(ModeSm* sm, ModeSm_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case ModeSm_StateId_CALIBRATION_STATES: CALIBRATION_STATES_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_CW_PA: CALIBRATE_CW_PA_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_FREQUENCY: CALIBRATE_FREQUENCY_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_RX_IQ: CALIBRATE_RX_IQ_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_SSB_PA: CALIBRATE_SSB_PA_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_TX_IQ_MARK: CALIBRATE_TX_IQ_MARK_exit(sm); break;
            
            case ModeSm_StateId_CALIBRATE_TX_IQ_SPACE: CALIBRATE_TX_IQ_SPACE_exit(sm); break;
            
            case ModeSm_StateId_NORMAL_STATES: NORMAL_STATES_exit(sm); break;
            
            case ModeSm_StateId_CW_RECEIVE: CW_RECEIVE_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_DAH_MARK: CW_TRANSMIT_DAH_MARK_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_DIT_MARK: CW_TRANSMIT_DIT_MARK_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE: CW_TRANSMIT_KEYER_SPACE_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT: CW_TRANSMIT_KEYER_WAIT_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_MARK: CW_TRANSMIT_MARK_exit(sm); break;
            
            case ModeSm_StateId_CW_TRANSMIT_SPACE: CW_TRANSMIT_SPACE_exit(sm); break;
            
            case ModeSm_StateId_SSB_RECEIVE: SSB_RECEIVE_exit(sm); break;
            
            case ModeSm_StateId_SSB_TRANSMIT: SSB_TRANSMIT_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATION_STATES
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATION_STATES_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATION_STATES_exit(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_ROOT;
}

static void CALIBRATION_STATES_ExitPoint_done__transition(ModeSm* sm)
{
    // CALIBRATION_STATES.<ExitPoint>(done) behavior
    // uml: TransitionTo(NORMAL_STATES)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        CALIBRATION_STATES_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `NORMAL_STATES`.
        NORMAL_STATES_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        NORMAL_STATES_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATION_STATES.<ExitPoint>(done)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_CW_PA
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_CW_PA_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_CW_PA;
    
    // CALIBRATE_CW_PA behavior
    // uml: enter / { CalibrateCWPAEnter(); }
    {
        // Step 1: execute action `CalibrateCWPAEnter();`
        CalibrateCWPAEnter();
    } // end of behavior for CALIBRATE_CW_PA
}

static void CALIBRATE_CW_PA_exit(ModeSm* sm)
{
    // CALIBRATE_CW_PA behavior
    // uml: exit / { CalibrateCWPAExit(); }
    {
        // Step 1: execute action `CalibrateCWPAExit();`
        CalibrateCWPAExit();
    } // end of behavior for CALIBRATE_CW_PA
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_CW_PA_calibrate_exit(ModeSm* sm)
{
    // CALIBRATE_CW_PA behavior
    // uml: CALIBRATE_EXIT TransitionTo(CALIBRATION_STATES.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_CW_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATION_STATES.<ExitPoint>(done)`.
        // CALIBRATION_STATES.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CALIBRATION_STATES_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATE_CW_PA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_FREQUENCY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_FREQUENCY_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_FREQUENCY;
    
    // CALIBRATE_FREQUENCY behavior
    // uml: enter / { CalibrateFrequencyEnter(); }
    {
        // Step 1: execute action `CalibrateFrequencyEnter();`
        CalibrateFrequencyEnter();
    } // end of behavior for CALIBRATE_FREQUENCY
}

static void CALIBRATE_FREQUENCY_exit(ModeSm* sm)
{
    // CALIBRATE_FREQUENCY behavior
    // uml: exit / { CalibrateFrequencyExit(); }
    {
        // Step 1: execute action `CalibrateFrequencyExit();`
        CalibrateFrequencyExit();
    } // end of behavior for CALIBRATE_FREQUENCY
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_FREQUENCY_calibrate_exit(ModeSm* sm)
{
    // CALIBRATE_FREQUENCY behavior
    // uml: CALIBRATE_EXIT TransitionTo(CALIBRATION_STATES.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_FREQUENCY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATION_STATES.<ExitPoint>(done)`.
        // CALIBRATION_STATES.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CALIBRATION_STATES_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATE_FREQUENCY
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_RX_IQ
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_RX_IQ_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_RX_IQ;
    
    // CALIBRATE_RX_IQ behavior
    // uml: enter / { CalibrateRXIQEnter(); }
    {
        // Step 1: execute action `CalibrateRXIQEnter();`
        CalibrateRXIQEnter();
    } // end of behavior for CALIBRATE_RX_IQ
}

static void CALIBRATE_RX_IQ_exit(ModeSm* sm)
{
    // CALIBRATE_RX_IQ behavior
    // uml: exit / { CalibrateRXIQExit(); }
    {
        // Step 1: execute action `CalibrateRXIQExit();`
        CalibrateRXIQExit();
    } // end of behavior for CALIBRATE_RX_IQ
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_RX_IQ_calibrate_exit(ModeSm* sm)
{
    // CALIBRATE_RX_IQ behavior
    // uml: CALIBRATE_EXIT TransitionTo(CALIBRATION_STATES.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_RX_IQ_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATION_STATES.<ExitPoint>(done)`.
        // CALIBRATION_STATES.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CALIBRATION_STATES_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATE_RX_IQ
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_SSB_PA
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_SSB_PA_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_SSB_PA;
    
    // CALIBRATE_SSB_PA behavior
    // uml: enter / { CalibrateSSBPAEnter(); }
    {
        // Step 1: execute action `CalibrateSSBPAEnter();`
        CalibrateSSBPAEnter();
    } // end of behavior for CALIBRATE_SSB_PA
}

static void CALIBRATE_SSB_PA_exit(ModeSm* sm)
{
    // CALIBRATE_SSB_PA behavior
    // uml: exit / { CalibrateSSBPAExit(); }
    {
        // Step 1: execute action `CalibrateSSBPAExit();`
        CalibrateSSBPAExit();
    } // end of behavior for CALIBRATE_SSB_PA
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_SSB_PA_calibrate_exit(ModeSm* sm)
{
    // CALIBRATE_SSB_PA behavior
    // uml: CALIBRATE_EXIT TransitionTo(CALIBRATION_STATES.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_SSB_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATION_STATES.<ExitPoint>(done)`.
        // CALIBRATION_STATES.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CALIBRATION_STATES_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATE_SSB_PA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_TX_IQ_MARK
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_TX_IQ_MARK_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_TX_IQ_MARK;
    
    // CALIBRATE_TX_IQ_MARK behavior
    // uml: enter / { CalibrateTXIQEnter(); }
    {
        // Step 1: execute action `CalibrateTXIQEnter();`
        CalibrateTXIQEnter();
    } // end of behavior for CALIBRATE_TX_IQ_MARK
}

static void CALIBRATE_TX_IQ_MARK_exit(ModeSm* sm)
{
    // CALIBRATE_TX_IQ_MARK behavior
    // uml: exit / { CalibrateTXIQExit(); }
    {
        // Step 1: execute action `CalibrateTXIQExit();`
        CalibrateTXIQExit();
    } // end of behavior for CALIBRATE_TX_IQ_MARK
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_TX_IQ_MARK_ptt_released(ModeSm* sm)
{
    // CALIBRATE_TX_IQ_MARK behavior
    // uml: PTT_RELEASED TransitionTo(CALIBRATE_TX_IQ_SPACE)
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_TX_IQ_MARK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ_SPACE`.
        CALIBRATE_TX_IQ_SPACE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_TX_IQ_MARK
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_TX_IQ_SPACE
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_TX_IQ_SPACE_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CALIBRATE_TX_IQ_SPACE;
    
    // CALIBRATE_TX_IQ_SPACE behavior
    // uml: enter / { CalibrateTXIQEnter(); }
    {
        // Step 1: execute action `CalibrateTXIQEnter();`
        CalibrateTXIQEnter();
    } // end of behavior for CALIBRATE_TX_IQ_SPACE
}

static void CALIBRATE_TX_IQ_SPACE_exit(ModeSm* sm)
{
    // CALIBRATE_TX_IQ_SPACE behavior
    // uml: exit / { CalibrateTXIQExit(); }
    {
        // Step 1: execute action `CalibrateTXIQExit();`
        CalibrateTXIQExit();
    } // end of behavior for CALIBRATE_TX_IQ_SPACE
    
    sm->state_id = ModeSm_StateId_CALIBRATION_STATES;
}

static void CALIBRATE_TX_IQ_SPACE_calibrate_exit(ModeSm* sm)
{
    // CALIBRATE_TX_IQ_SPACE behavior
    // uml: CALIBRATE_EXIT TransitionTo(CALIBRATION_STATES.<ExitPoint>(done))
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_TX_IQ_SPACE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATION_STATES.<ExitPoint>(done)`.
        // CALIBRATION_STATES.<ExitPoint>(done) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        CALIBRATION_STATES_ExitPoint_done__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for CALIBRATE_TX_IQ_SPACE
    
    // No ancestor handles this event.
}

static void CALIBRATE_TX_IQ_SPACE_ptt_pressed(ModeSm* sm)
{
    // CALIBRATE_TX_IQ_SPACE behavior
    // uml: PTT_PRESSED TransitionTo(CALIBRATE_TX_IQ_MARK)
    {
        // Step 1: Exit states until we reach `CALIBRATION_STATES` state (Least Common Ancestor for transition).
        CALIBRATE_TX_IQ_SPACE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ_MARK`.
        CALIBRATE_TX_IQ_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_TX_IQ_SPACE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NORMAL_STATES
////////////////////////////////////////////////////////////////////////////////

static void NORMAL_STATES_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void NORMAL_STATES_exit(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_ROOT;
}

static void NORMAL_STATES_calibrate_cw_pa(ModeSm* sm)
{
    // NORMAL_STATES behavior
    // uml: CALIBRATE_CW_PA TransitionTo(CALIBRATE_CW_PA)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ModeSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CW_PA`.
        CALIBRATION_STATES_enter(sm);
        CALIBRATE_CW_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES
    
    // No ancestor handles this event.
}

static void NORMAL_STATES_calibrate_frequency(ModeSm* sm)
{
    // NORMAL_STATES behavior
    // uml: CALIBRATE_FREQUENCY TransitionTo(CALIBRATE_FREQUENCY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ModeSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_FREQUENCY`.
        CALIBRATION_STATES_enter(sm);
        CALIBRATE_FREQUENCY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES
    
    // No ancestor handles this event.
}

static void NORMAL_STATES_calibrate_rx_iq(ModeSm* sm)
{
    // NORMAL_STATES behavior
    // uml: CALIBRATE_RX_IQ TransitionTo(CALIBRATE_RX_IQ)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ModeSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_RX_IQ`.
        CALIBRATION_STATES_enter(sm);
        CALIBRATE_RX_IQ_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES
    
    // No ancestor handles this event.
}

static void NORMAL_STATES_calibrate_ssb_pa(ModeSm* sm)
{
    // NORMAL_STATES behavior
    // uml: CALIBRATE_SSB_PA TransitionTo(CALIBRATE_SSB_PA)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ModeSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_SSB_PA`.
        CALIBRATION_STATES_enter(sm);
        CALIBRATE_SSB_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES
    
    // No ancestor handles this event.
}

static void NORMAL_STATES_calibrate_tx_iq(ModeSm* sm)
{
    // NORMAL_STATES behavior
    // uml: CALIBRATE_TX_IQ TransitionTo(CALIBRATE_TX_IQ_SPACE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, ModeSm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ_SPACE`.
        CALIBRATION_STATES_enter(sm);
        CALIBRATE_TX_IQ_SPACE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES
    
    // No ancestor handles this event.
}

static void NORMAL_STATES_InitialState_transition(ModeSm* sm)
{
    // NORMAL_STATES.<InitialState> behavior
    // uml: TransitionTo(SSB_RECEIVE)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SSB_RECEIVE`.
        SSB_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for NORMAL_STATES.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_RECEIVE
////////////////////////////////////////////////////////////////////////////////

static void CW_RECEIVE_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_RECEIVE;
    
    // CW_RECEIVE behavior
    // uml: enter / { ModeCWReceiveEnter(); }
    {
        // Step 1: execute action `ModeCWReceiveEnter();`
        ModeCWReceiveEnter();
    } // end of behavior for CW_RECEIVE
}

static void CW_RECEIVE_exit(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: exit / { ModeCWReceiveExit(); }
    {
        // Step 1: execute action `ModeCWReceiveExit();`
        ModeCWReceiveExit();
    } // end of behavior for CW_RECEIVE
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_RECEIVE_dah_pressed(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: DAH_PRESSED TransitionTo(CW_TRANSMIT_DAH_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_DAH_MARK`.
        CW_TRANSMIT_DAH_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_RECEIVE
    
    // No ancestor handles this event.
}

static void CW_RECEIVE_dit_pressed(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: DIT_PRESSED TransitionTo(CW_TRANSMIT_DIT_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_DIT_MARK`.
        CW_TRANSMIT_DIT_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_RECEIVE
    
    // No ancestor handles this event.
}

static void CW_RECEIVE_do(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: 1. do / { markCount_ms = 0; }
    {
        // Step 1: execute action `markCount_ms = 0;`
        sm->vars.markCount_ms = 0;
    } // end of behavior for CW_RECEIVE
    
    // No ancestor handles this event.
}

static void CW_RECEIVE_key_pressed(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: KEY_PRESSED TransitionTo(CW_TRANSMIT_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_MARK`.
        CW_TRANSMIT_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_RECEIVE
    
    // No ancestor handles this event.
}

static void CW_RECEIVE_to_ssb_mode(ModeSm* sm)
{
    // CW_RECEIVE behavior
    // uml: TO_SSB_MODE TransitionTo(SSB_RECEIVE)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SSB_RECEIVE`.
        SSB_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_RECEIVE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_DAH_MARK
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_DAH_MARK_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_DAH_MARK;
    
    // CW_TRANSMIT_DAH_MARK behavior
    // uml: enter / { ModeCWTransmitMarkEnter(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkEnter();`
        ModeCWTransmitMarkEnter();
    } // end of behavior for CW_TRANSMIT_DAH_MARK
    
    // CW_TRANSMIT_DAH_MARK behavior
    // uml: enter / { markCount_ms = 0; }
    {
        // Step 1: execute action `markCount_ms = 0;`
        sm->vars.markCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_DAH_MARK
}

static void CW_TRANSMIT_DAH_MARK_exit(ModeSm* sm)
{
    // CW_TRANSMIT_DAH_MARK behavior
    // uml: exit / { ModeCWTransmitMarkExit(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkExit();`
        ModeCWTransmitMarkExit();
    } // end of behavior for CW_TRANSMIT_DAH_MARK
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_DAH_MARK_do(ModeSm* sm)
{
    // CW_TRANSMIT_DAH_MARK behavior
    // uml: 1. do / { markCount_ms++;\nspaceCount_ms = 0; }
    {
        // Step 1: execute action `markCount_ms++;\nspaceCount_ms = 0;`
        sm->vars.markCount_ms++;
        sm->vars.spaceCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_DAH_MARK
    
    // CW_TRANSMIT_DAH_MARK behavior
    // uml: do [markCount_ms >= 3*ditDuration_ms] TransitionTo(CW_TRANSMIT_KEYER_SPACE)
    if (sm->vars.markCount_ms >= 3*sm->vars.ditDuration_ms)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_DAH_MARK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_KEYER_SPACE`.
        CW_TRANSMIT_KEYER_SPACE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_DAH_MARK
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_DIT_MARK
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_DIT_MARK_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_DIT_MARK;
    
    // CW_TRANSMIT_DIT_MARK behavior
    // uml: enter / { ModeCWTransmitMarkEnter(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkEnter();`
        ModeCWTransmitMarkEnter();
    } // end of behavior for CW_TRANSMIT_DIT_MARK
    
    // CW_TRANSMIT_DIT_MARK behavior
    // uml: enter / { markCount_ms = 0; }
    {
        // Step 1: execute action `markCount_ms = 0;`
        sm->vars.markCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_DIT_MARK
}

static void CW_TRANSMIT_DIT_MARK_exit(ModeSm* sm)
{
    // CW_TRANSMIT_DIT_MARK behavior
    // uml: exit / { ModeCWTransmitMarkExit(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkExit();`
        ModeCWTransmitMarkExit();
    } // end of behavior for CW_TRANSMIT_DIT_MARK
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_DIT_MARK_do(ModeSm* sm)
{
    // CW_TRANSMIT_DIT_MARK behavior
    // uml: 1. do / { markCount_ms++;\nspaceCount_ms = 0; }
    {
        // Step 1: execute action `markCount_ms++;\nspaceCount_ms = 0;`
        sm->vars.markCount_ms++;
        sm->vars.spaceCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_DIT_MARK
    
    // CW_TRANSMIT_DIT_MARK behavior
    // uml: do [markCount_ms >= ditDuration_ms] TransitionTo(CW_TRANSMIT_KEYER_SPACE)
    if (sm->vars.markCount_ms >= sm->vars.ditDuration_ms)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_DIT_MARK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_KEYER_SPACE`.
        CW_TRANSMIT_KEYER_SPACE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_DIT_MARK
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_KEYER_SPACE
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_KEYER_SPACE_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE;
    
    // CW_TRANSMIT_KEYER_SPACE behavior
    // uml: enter / { ModeCWTransmitSpaceEnter(); }
    {
        // Step 1: execute action `ModeCWTransmitSpaceEnter();`
        ModeCWTransmitSpaceEnter();
    } // end of behavior for CW_TRANSMIT_KEYER_SPACE
    
    // CW_TRANSMIT_KEYER_SPACE behavior
    // uml: enter / { spaceCount_ms = 0; }
    {
        // Step 1: execute action `spaceCount_ms = 0;`
        sm->vars.spaceCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_KEYER_SPACE
}

static void CW_TRANSMIT_KEYER_SPACE_exit(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_KEYER_SPACE_do(ModeSm* sm)
{
    // CW_TRANSMIT_KEYER_SPACE behavior
    // uml: 1. do / { spaceCount_ms++;\nmarkCount_ms = 0; }
    {
        // Step 1: execute action `spaceCount_ms++;\nmarkCount_ms = 0;`
        sm->vars.spaceCount_ms++;
        sm->vars.markCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_KEYER_SPACE
    
    // CW_TRANSMIT_KEYER_SPACE behavior
    // uml: do [spaceCount_ms >= ditDuration_ms] TransitionTo(CW_TRANSMIT_KEYER_WAIT)
    if (sm->vars.spaceCount_ms >= sm->vars.ditDuration_ms)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_KEYER_SPACE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_KEYER_WAIT`.
        CW_TRANSMIT_KEYER_WAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_KEYER_SPACE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_KEYER_WAIT
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_KEYER_WAIT_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT;
    
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: enter / { spaceCount_ms = 0; }
    {
        // Step 1: execute action `spaceCount_ms = 0;`
        sm->vars.spaceCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
}

static void CW_TRANSMIT_KEYER_WAIT_exit(ModeSm* sm)
{
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: exit / { ModeCWTransmitSpaceExit(); }
    {
        // Step 1: execute action `ModeCWTransmitSpaceExit();`
        ModeCWTransmitSpaceExit();
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_KEYER_WAIT_dah_pressed(ModeSm* sm)
{
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: DAH_PRESSED TransitionTo(CW_TRANSMIT_DAH_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_KEYER_WAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_DAH_MARK`.
        CW_TRANSMIT_DAH_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
    
    // No ancestor handles this event.
}

static void CW_TRANSMIT_KEYER_WAIT_dit_pressed(ModeSm* sm)
{
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: DIT_PRESSED TransitionTo(CW_TRANSMIT_DIT_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_KEYER_WAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_DIT_MARK`.
        CW_TRANSMIT_DIT_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
    
    // No ancestor handles this event.
}

static void CW_TRANSMIT_KEYER_WAIT_do(ModeSm* sm)
{
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: 1. do / { spaceCount_ms++;\nmarkCount_ms = 0; }
    {
        // Step 1: execute action `spaceCount_ms++;\nmarkCount_ms = 0;`
        sm->vars.spaceCount_ms++;
        sm->vars.markCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
    
    // CW_TRANSMIT_KEYER_WAIT behavior
    // uml: do [spaceCount_ms >= waitDuration_ms] TransitionTo(CW_RECEIVE)
    if (sm->vars.spaceCount_ms >= sm->vars.waitDuration_ms)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_KEYER_WAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_RECEIVE`.
        CW_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_KEYER_WAIT
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_MARK
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_MARK_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_MARK;
    
    // CW_TRANSMIT_MARK behavior
    // uml: enter / { ModeCWTransmitMarkEnter(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkEnter();`
        ModeCWTransmitMarkEnter();
    } // end of behavior for CW_TRANSMIT_MARK
}

static void CW_TRANSMIT_MARK_exit(ModeSm* sm)
{
    // CW_TRANSMIT_MARK behavior
    // uml: exit / { ModeCWTransmitMarkExit(); }
    {
        // Step 1: execute action `ModeCWTransmitMarkExit();`
        ModeCWTransmitMarkExit();
    } // end of behavior for CW_TRANSMIT_MARK
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_MARK_key_released(ModeSm* sm)
{
    // CW_TRANSMIT_MARK behavior
    // uml: KEY_RELEASED TransitionTo(CW_TRANSMIT_SPACE)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_MARK_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_SPACE`.
        CW_TRANSMIT_SPACE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_MARK
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CW_TRANSMIT_SPACE
////////////////////////////////////////////////////////////////////////////////

static void CW_TRANSMIT_SPACE_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_CW_TRANSMIT_SPACE;
    
    // CW_TRANSMIT_SPACE behavior
    // uml: enter / { ModeCWTransmitSpaceEnter(); }
    {
        // Step 1: execute action `ModeCWTransmitSpaceEnter();`
        ModeCWTransmitSpaceEnter();
    } // end of behavior for CW_TRANSMIT_SPACE
    
    // CW_TRANSMIT_SPACE behavior
    // uml: enter / { spaceCount_ms = 0; }
    {
        // Step 1: execute action `spaceCount_ms = 0;`
        sm->vars.spaceCount_ms = 0;
    } // end of behavior for CW_TRANSMIT_SPACE
}

static void CW_TRANSMIT_SPACE_exit(ModeSm* sm)
{
    // CW_TRANSMIT_SPACE behavior
    // uml: exit / { ModeCWTransmitSpaceExit(); }
    {
        // Step 1: execute action `ModeCWTransmitSpaceExit();`
        ModeCWTransmitSpaceExit();
    } // end of behavior for CW_TRANSMIT_SPACE
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void CW_TRANSMIT_SPACE_do(ModeSm* sm)
{
    // CW_TRANSMIT_SPACE behavior
    // uml: 1. do / { spaceCount_ms++; }
    {
        // Step 1: execute action `spaceCount_ms++;`
        sm->vars.spaceCount_ms++;
    } // end of behavior for CW_TRANSMIT_SPACE
    
    // CW_TRANSMIT_SPACE behavior
    // uml: do [spaceCount_ms >= waitDuration_ms] TransitionTo(CW_RECEIVE)
    if (sm->vars.spaceCount_ms >= sm->vars.waitDuration_ms)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_SPACE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_RECEIVE`.
        CW_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_SPACE
    
    // No ancestor handles this event.
}

static void CW_TRANSMIT_SPACE_key_pressed(ModeSm* sm)
{
    // CW_TRANSMIT_SPACE behavior
    // uml: KEY_PRESSED TransitionTo(CW_TRANSMIT_MARK)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        CW_TRANSMIT_SPACE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_TRANSMIT_MARK`.
        CW_TRANSMIT_MARK_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CW_TRANSMIT_SPACE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SSB_RECEIVE
////////////////////////////////////////////////////////////////////////////////

static void SSB_RECEIVE_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_SSB_RECEIVE;
    
    // SSB_RECEIVE behavior
    // uml: enter / { ModeSSBReceiveEnter(); }
    {
        // Step 1: execute action `ModeSSBReceiveEnter();`
        ModeSSBReceiveEnter();
    } // end of behavior for SSB_RECEIVE
}

static void SSB_RECEIVE_exit(ModeSm* sm)
{
    // SSB_RECEIVE behavior
    // uml: exit / { ModeSSBReceiveExit(); }
    {
        // Step 1: execute action `ModeSSBReceiveExit();`
        ModeSSBReceiveExit();
    } // end of behavior for SSB_RECEIVE
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void SSB_RECEIVE_ptt_pressed(ModeSm* sm)
{
    // SSB_RECEIVE behavior
    // uml: PTT_PRESSED TransitionTo(SSB_TRANSMIT)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        SSB_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SSB_TRANSMIT`.
        SSB_TRANSMIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SSB_RECEIVE
    
    // No ancestor handles this event.
}

static void SSB_RECEIVE_to_cw_mode(ModeSm* sm)
{
    // SSB_RECEIVE behavior
    // uml: TO_CW_MODE TransitionTo(CW_RECEIVE)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        SSB_RECEIVE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CW_RECEIVE`.
        CW_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SSB_RECEIVE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SSB_TRANSMIT
////////////////////////////////////////////////////////////////////////////////

static void SSB_TRANSMIT_enter(ModeSm* sm)
{
    sm->state_id = ModeSm_StateId_SSB_TRANSMIT;
    
    // SSB_TRANSMIT behavior
    // uml: enter / { ModeSSBTransmitEnter(); }
    {
        // Step 1: execute action `ModeSSBTransmitEnter();`
        ModeSSBTransmitEnter();
    } // end of behavior for SSB_TRANSMIT
}

static void SSB_TRANSMIT_exit(ModeSm* sm)
{
    // SSB_TRANSMIT behavior
    // uml: exit / { ModeSSBTransmitExit(); }
    {
        // Step 1: execute action `ModeSSBTransmitExit();`
        ModeSSBTransmitExit();
    } // end of behavior for SSB_TRANSMIT
    
    sm->state_id = ModeSm_StateId_NORMAL_STATES;
}

static void SSB_TRANSMIT_ptt_released(ModeSm* sm)
{
    // SSB_TRANSMIT behavior
    // uml: PTT_RELEASED TransitionTo(SSB_RECEIVE)
    {
        // Step 1: Exit states until we reach `NORMAL_STATES` state (Least Common Ancestor for transition).
        SSB_TRANSMIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SSB_RECEIVE`.
        SSB_RECEIVE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SSB_TRANSMIT
    
    // No ancestor handles this event.
}

// Thread safe.
char const * ModeSm_state_id_to_string(ModeSm_StateId id)
{
    switch (id)
    {
        case ModeSm_StateId_ROOT: return "ROOT";
        case ModeSm_StateId_CALIBRATION_STATES: return "CALIBRATION_STATES";
        case ModeSm_StateId_CALIBRATE_CW_PA: return "CALIBRATE_CW_PA";
        case ModeSm_StateId_CALIBRATE_FREQUENCY: return "CALIBRATE_FREQUENCY";
        case ModeSm_StateId_CALIBRATE_RX_IQ: return "CALIBRATE_RX_IQ";
        case ModeSm_StateId_CALIBRATE_SSB_PA: return "CALIBRATE_SSB_PA";
        case ModeSm_StateId_CALIBRATE_TX_IQ_MARK: return "CALIBRATE_TX_IQ_MARK";
        case ModeSm_StateId_CALIBRATE_TX_IQ_SPACE: return "CALIBRATE_TX_IQ_SPACE";
        case ModeSm_StateId_NORMAL_STATES: return "NORMAL_STATES";
        case ModeSm_StateId_CW_RECEIVE: return "CW_RECEIVE";
        case ModeSm_StateId_CW_TRANSMIT_DAH_MARK: return "CW_TRANSMIT_DAH_MARK";
        case ModeSm_StateId_CW_TRANSMIT_DIT_MARK: return "CW_TRANSMIT_DIT_MARK";
        case ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE: return "CW_TRANSMIT_KEYER_SPACE";
        case ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT: return "CW_TRANSMIT_KEYER_WAIT";
        case ModeSm_StateId_CW_TRANSMIT_MARK: return "CW_TRANSMIT_MARK";
        case ModeSm_StateId_CW_TRANSMIT_SPACE: return "CW_TRANSMIT_SPACE";
        case ModeSm_StateId_SSB_RECEIVE: return "SSB_RECEIVE";
        case ModeSm_StateId_SSB_TRANSMIT: return "SSB_TRANSMIT";
        default: return "?";
    }
}

// Thread safe.
char const * ModeSm_event_id_to_string(ModeSm_EventId id)
{
    switch (id)
    {
        case ModeSm_EventId_CALIBRATE_CW_PA: return "CALIBRATE_CW_PA";
        case ModeSm_EventId_CALIBRATE_EXIT: return "CALIBRATE_EXIT";
        case ModeSm_EventId_CALIBRATE_FREQUENCY: return "CALIBRATE_FREQUENCY";
        case ModeSm_EventId_CALIBRATE_RX_IQ: return "CALIBRATE_RX_IQ";
        case ModeSm_EventId_CALIBRATE_SSB_PA: return "CALIBRATE_SSB_PA";
        case ModeSm_EventId_CALIBRATE_TX_IQ: return "CALIBRATE_TX_IQ";
        case ModeSm_EventId_DAH_PRESSED: return "DAH_PRESSED";
        case ModeSm_EventId_DIT_PRESSED: return "DIT_PRESSED";
        case ModeSm_EventId_DO: return "DO";
        case ModeSm_EventId_KEY_PRESSED: return "KEY_PRESSED";
        case ModeSm_EventId_KEY_RELEASED: return "KEY_RELEASED";
        case ModeSm_EventId_PTT_PRESSED: return "PTT_PRESSED";
        case ModeSm_EventId_PTT_RELEASED: return "PTT_RELEASED";
        case ModeSm_EventId_TO_CW_MODE: return "TO_CW_MODE";
        case ModeSm_EventId_TO_SSB_MODE: return "TO_SSB_MODE";
        default: return "?";
    }
}
