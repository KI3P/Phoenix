/**
 * @file PhoenixSketch.ino
 * @brief Main entry point for Phoenix SDR transceiver firmware
 *
 * ============================================================================
 * PHOENIX SDR SOFTWARE ARCHITECTURE
 * ============================================================================
 *
 * OVERVIEW
 * --------
 * The Phoenix SDR is a Teensy 4.1-based amateur radio transceiver implementing
 * a complete software-defined radio system. The architecture is designed around:
 * - **State machines** for deterministic hardware control
 * - **Real-time DSP** for signal processing
 * - **Event-driven operation** for responsive user interaction
 * - **Hardware abstraction** for testability and modularity
 *
 * DESIGN PHILOSOPHY
 * -----------------
 * 1. **Separation of Concerns**: Hardware control, signal processing, UI, and
 *    display are isolated into separate modules with clear interfaces.
 *
 * 2. **State Machine Control**: All hardware state changes flow through state
 *    machines (ModeSm, UISm, TuneSm) ensuring deterministic, predictable behavior.
 *
 * 3. **Real-Time Constraints**: The main loop must complete within 10ms to
 *    prevent audio buffer overflows. Display updates are rate-limited.
 *
 * 4. **Read-Only Display**: Display code reads global state but never modifies
 *    it, preventing unintended side effects.
 *
 * 5. **Hardware Abstraction**: Hardware interfaces (RFBoard, LPFBoard, BPFBoard)
 *    provide clean APIs, allowing mocking for unit tests.
 *
 * SYSTEM ARCHITECTURE
 * -------------------
 *
 * ┌─────────────────────────────────────────────────────────────────────┐
 * │                         PHOENIX SDR FIRMWARE                        │
 * ├─────────────────────────────────────────────────────────────────────┤
 * │                       State Machines                                │
 * │  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐           │
 * │  │   ModeSm     │    │    UISm      │    │   TuneSm     │           │
 * │  │  (Operating  │    │    (User     │    │  (Frequency  │           │
 * │  │   Modes)     │    │  Interface)  │    │   Control)   │           │
 * │  └──────┬───────┘    └──────┬───────┘    └──────┬───────┘           │
 * │         │                   │                   │                   │
 * │         │                   │                   │                   │
 * │  ┌──────▼───────────────────▼───────────────────▼────────┐          │
 * │  │              Main Loop (Loop.cpp)                     │          │
 * │  │  - Check for interrupts from encoders/buttons         │          │
 * │  │  - Dispatch events to state machines                  │          │
 * │  │  - Update hardware based on state changes             │          │
 * │  │  - Perform signal processing                          │          │
 * │  │  - Refresh display                                    │          │
 * │  └──────┬───────────────────┬───────────────────┬────────┘          │
 * │         │                   │                   │                   │
 * │  ┌──────▼───────┐    ┌──────▼───────┐    ┌──────▼───────┐           │
 * │  │     RF       │    │  DSP Chain   │    │   Display    │           │
 * │  │  Hardware    │    │  (OpenAudio) │    │  (RA8875)    │           │
 * │  └──────────────┘    └──────────────┘    └──────────────┘           │
 * │                                                                     │
 * └─────────────────────────────────────────────────────────────────────┘
 *
 * STATE MACHINES
 * --------------
 * Generated by StateSmith from UML diagrams, these provide deterministic control:
 *
 * **ModeSm** (ModeSm.cpp/h) - Operating mode control
 *   States: SSB_RECEIVE, SSB_TRANSMIT, CW_RECEIVE, CW_TRANSMIT, TUNE
 *   - Controls TX/RX switching, VFO selection, modulation routing
 *   - Handles CW keyer timing and character generation
 *   - Manages transmit timeouts and safety interlocks
 *
 * **UISm** (UISm.cpp/h) - User interface navigation
 *   States: SPLASH, HOME, MAIN_MENU, SECONDARY_MENU, UPDATE
 *   - Controls display screen transitions
 *   - Manages menu navigation hierarchy
 *   - Handles parameter adjustment workflow
 *
 * **TuneSm** (Tune.cpp/h) - Frequency control (this one isn't generated by StateSmith)
 *   States: TuneReceive, TuneSSBTX, TuneCWTX
 *   - Sets appropriate VFO for current mode
 *   - Applies CW tone offset in CW mode
 *   - Coordinates SSB I/Q or CW single-output VFO selection
 *
 * MAIN EXECUTION FLOW
 * -------------------
 * 1. **setup()** (PhoenixSketch.ino)
 *    - Initialize hardware (display, audio, RF boards, front panel)
 *    - Load settings from EEPROM
 *    - Start state machines
 *    - Begin 1ms timer for state machine DO events
 *
 * 2. **loop()** (Loop.cpp) - Runs continuously, ~10ms per iteration
 *    - Poll front panel encoders and buttons
 *    - Dispatch events to state machines based on user input
 *    - Update hardware (VFO frequency, filters, attenuators)
 *    - Process CAT control commands
 *    - Perform signal processing
 *    - Update display (rate-limited to 200ms for spectrum)
 *    - Monitor temperature and handle shutdown requests
 *
 * 3. **tick1ms()** (PhoenixSketch.ino) - Interrupt-driven, every 1ms
 *    - Dispatch DO events to ModeSm for CW keyer timing
 *    - Dispatch DO events to UISm for timeout handling
 *
 * MODULE ORGANIZATION
 * -------------------
 * **Hardware Control:**
 * - RFBoard.cpp/h: Si5351 VFO control, TX/RX switching, attenuators
 * - LPFBoard.cpp/h: Low-pass filter relay selection
 * - BPFBoard.cpp/h: Band-pass filter relay selection
 * - FrontPanel.cpp/h: Encoder and button input handling
 *
 * **Signal Processing:**
 * - DSP.cpp/h: Audio routing, AGC, filter coordination
 * - DSP_FFT.cpp/h: Spectrum analysis for display
 * - DSP_FIR.cpp/h: FIR filter coefficient management
 * - DSP_Noise.cpp/h: Noise reduction algorithms
 * - DSP_CWProcessing.cpp/h: CW audio filtering and tone decoding
 * - MainBoard_AudioIO.cpp/h: Audio codec interface
 *
 * **User Interface:**
 * - MainBoard_Display.cpp/h: Display rendering (12-pane layout)
 * - UISm.cpp/h: UI state machine (generated by StateSmith)
 *
 * **Radio Control:**
 * - ModeSm.cpp/h: Operating mode state machine (generated by StateSmith)
 * - Tune.cpp/h: Frequency tuning state machine
 * - CAT.cpp/h: Computer control protocol (Kenwood emulation)
 *
 * **Program Execution and Flow Control:**
 * - Loop.cpp/h: Main loop execution and event handling
 * 
 * **Configuration:**
 * - Config.h: Pin definitions, constants, system configuration
 * - SDT.h: System data types and global state (ED structure)
 * - Storage.cpp/h: EEPROM persistence for settings
 * - Globals.cpp: Global variable definitions
 *
 * PERSITENT CONFIGURATION
 * ------------
 * The `ED` (EEPROM Data) structure in SDT.h holds the radio operating configuration.
 * This persists across power cycles and is saved to EEPROM and SDCard (if present).
 * - Frequencies, band settings, filter parameters
 * - Volume, gain, AGC settings
 * - Display preferences, spectrum zoom
 * - Calibration data
 *
 * TIMING CONSTRAINTS
 * ------------------
 * - **Main loop**: Must complete in <10ms to prevent audio buffer overflow
 * - **Spectrum refresh**: Limited to 200ms intervals to reduce CPU load
 * - **Display updates**: Pane-based with "stale" flags for efficiency
 * - **CW keyer**: 1ms timer ensures precise dit/dah timing
 * - **State machine transitions**: Deterministic, low-latency
 *
 * TESTING STRATEGY
 * ----------------
 * - **Unit tests**: Google Test framework (code/test/)
 * - **Mocking**: Arduino, Si5351, GPIO, and audio interfaces mocked
 * - **State machine tests**: Verify all transitions and edge cases
 * - **Hardware abstraction**: Enables testing without physical hardware
 * - **Build system**: CMake for test compilation, Arduino IDE for firmware
 *
 * For more details, see:
 * - CLAUDE.md: Project overview and development guidelines
 * - Individual module .cpp/.h files: Implementation details
 * - code/test/: Unit tests demonstrating module usage
 */

#include "SDT.h"

// Create an IntervalTimer object for driving the state machines
IntervalTimer timer1ms;

/**
 * This is run every 1ms. It dispatches do events to the state machines which
 * are needed for time dependent state changes like the CW keyer
 */
void tick1ms(void){
    ModeSm_dispatch_event(&modeSM, ModeSm_EventId_DO);
    UISm_dispatch_event(&uiSM, UISm_EventId_DO);
}

void setup(void){
    Serial.begin(115200);
    SerialUSB1.begin(38400); // For CAT control
    Serial.println("T41 SDT Setup");
    //Configure the pins for the auto shutdown
    pinMode(BEGIN_TEENSY_SHUTDOWN, INPUT);  // HI received here tells Teensy to start shutdown routine
    pinMode(SHUTDOWN_COMPLETE, OUTPUT);     // HI sent here tells ATTiny85 to cut the power
    digitalWrite(SHUTDOWN_COMPLETE, 0);  

    // Used to write the state to 4-bit readout for state timing measurements
    pinMode(31,OUTPUT); //testcode
    pinMode(30,OUTPUT); //testcode
    pinMode(29,OUTPUT); //testcode
    pinMode(28,OUTPUT); //testcode
    Flag(0);
    
    Serial.println("...Initializing storage");
    InitializeStorage();

    Serial.println("...Initializing hardware");
    InitializeFrontPanel();
    InitializeSignalProcessing();  // Initialize DSP before starting audio
    InitializeAudio();
    InitializeDisplay();
    InitializeRFHardware(); // RF board, LPF board, and BPF board
    
    // Initialize temperature monitoring
    uint16_t temp_check_frequency = 0x03U;  //updates the temp value at a RTC/3 clock rate
    //0xFFFF determines a 2 second sample rate period
    uint32_t highAlarmTemp = 85U;  //42 degrees C
    uint32_t lowAlarmTemp = 25U;
    uint32_t panicAlarmTemp = 90U;
    initTempMon(temp_check_frequency, lowAlarmTemp, highAlarmTemp, panicAlarmTemp);
    // this starts the measurements
    TEMPMON_TEMPSENSE0 |= 0x2U;

    // Start the mode state machines
    Serial.println("...Starting state machines");
    modeSM.vars.waitDuration_ms = CW_TRANSMIT_SPACE_TIMEOUT_MS;
    UpdateDitLength();
    ModeSm_start(&modeSM);
    uiSM.vars.splashDuration_ms = SPLASH_DURATION_MS;
    UISm_start(&uiSM);

    UpdateAudioIOState();

    Serial.println("...Setting up key interrupts");
    SetupCWKeyInterrupts();

    timer1ms.begin(tick1ms, 1000);  // run tick1ms every 1ms
    
    Serial.println("...Setup done!");
}
