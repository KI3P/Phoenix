/**
 * @file HardwareSm.cpp
 * @brief RF Hardware State Machine Coordinator
 *
 * ARCHITECTURE OVERVIEW
 * =====================
 * This module serves as the bridge between the high-level radio operating mode state
 * machine (ModeSm) and the low-level RF hardware control modules. It translates abstract
 * radio states (SSB_RECEIVE, CW_TRANSMIT, etc.) into concrete hardware configurations.
 *
 * STATE MACHINE ARCHITECTURE
 * --------------------------
 * The Phoenix SDR uses a two-tier state machine architecture:
 *
 * 1. ModeSm (Mode State Machine - generated by StateSmith):
 *    - High-level operating modes: SSB_RECEIVE, SSB_TRANSMIT, CW_RECEIVE, CW_TRANSMIT, etc.
 *    - Handles user interaction and mode logic
 *    - State changes triggered by button presses, PTT, keyer input
 *
 * 2. RF Hardware States (managed by this module):
 *    - RFReceive: Configure hardware for receiving signals
 *    - RFTransmit: Configure hardware for SSB transmission
 *    - RFCWMark: CW transmission with carrier on (key down)
 *    - RFCWSpace: CW transmission with carrier off (key up)
 *    - RFCalIQ: Calibration mode (not yet implemented)
 *
 * 3. Tune State Machine (frequency management):
 *    - TuneReceive: Set VFO for RX with IF offset
 *    - TuneSSBTX: Set VFO for SSB TX at carrier frequency
 *    - TuneCWTX: Set VFO for CW TX with tone offset
 *
 * HARDWARE MODULES CONTROLLED
 * ---------------------------
 * This module coordinates the following hardware subsystems:
 * - VFOs (RF board Si5351): SSB and CW local oscillators
 * - Attenuators: RX (RF board GPA) and TX (RF board GPB) signal level control
 * - BPF Board: Band-pass RXfilters for RX and TX paths
 * - LPF Board: Low-pass RXfilters for harmonic suppression
 * - TX/RX Switching: Relay control for antenna routing
 * - Modulation Selection: SSB vs CW modulation routing
 * - Calibration Feedback: IQ calibration signal path
 *
 * KEY DESIGN PRINCIPLES
 * ---------------------
 * - State transitions follow carefully sequenced hardware operations to prevent
 *   RF power spikes or relay damage (RX components disabled before TX enabled)
 * - Delays (MyDelay) ensure relay and PIN diode settling times
 * - Multiple ModeSm states can map to the same RF hardware state (optimization)
 * - Frequency changes are handled independently via the tune state machine
 * - State tracking prevents redundant hardware reconfigurations
 *
 * INTEGRATION WITH OTHER MODULES
 * ------------------------------
 * - Called from main Loop: UpdateRFHardwareState() in each iteration
 * - Uses RFBoard.cpp functions for low-level hardware control
 * - Reads ED (EEPROM Data) for band-specific settings (attenuation, RXfilters)
 * - Coordinates with Tune.cpp for VFO frequency management
 *
 * REAL-TIME CONSIDERATIONS
 * ------------------------
 * - Must complete within main loop timing budget (10ms)
 * - State changes are event-driven, not polled continuously
 * - Hardware delays are necessary but kept to minimum required values
 *
 * @see ModeSm.cpp - High-level radio mode state machine
 * @see RFBoard.cpp - Low-level RF hardware control functions
 * @see Tune.cpp - VFO frequency management
 * @see T41_V12_board_api.drawio - Hardware state transition diagrams
 */

#include "SDT.h"

static ModeSm_StateId previousRadioState = ModeSm_StateId_ROOT;
static RFHardwareState rfHardwareState = RFReceive;
static RFHardwareState oldrfHardwareState = RFInvalid;
static TuneState tuneState = TuneReceive;

/**
 * @brief Initialize the RF board by calling the initialization functions for each
 * of the modules hosted on the RF board:
 *   - Attenuators (RX and TX)
 *   - SSB VFO (Si5351 clock 0)
 *   - CW VFO (Si5351 clock 1)
 *   - Transmit modulation control
 *   - Calibration control
 *   - RXTX control (relay switching)
 *
 * Also resets internal state tracking variables to force proper initialization
 * upon first state machine entry.
 *
 * @return errno_t Sum of error codes from all initialization functions (0 = success)
 */
errno_t InitializeRFBoard(void){
    errno_t err = InitAttenuation();
    err += InitCalFeedbackControl();
    err += InitTXModulation();
    err += InitVFOs();
    err += InitRXTX();

    // force the initialization to RF receive upon state machine entry
    oldrfHardwareState = RFInvalid;
    previousRadioState = ModeSm_StateId_ROOT;
    tuneState = TuneInvalid;
    return err;
}

/**
 * @brief Initialize all RF hardware subsystems
 *
 * Top-level initialization function that initializes:
 * - LPF Board (low-pass RXfilters)
 * - BPF Board (band-pass RXfilters)
 * - RF Board (VFOs, attenuators, TX/RX switching)
 *
 * This function should be called once during system startup before
 * entering the main program loop.
 *
 * @return errno_t Sum of error codes from all subsystems (0 = success)
 */
errno_t InitializeRFHardware(void){
    errno_t val = InitializeLPFBoard();
    val += InitializeBPFBoard();
    val += InitializeRFBoard();
    return val;
}

////////////////////////////////////////////////////////////////////////////////////
// State machine code
////////////////////////////////////////////////////////////////////////////////////

/**
 * @brief Get the previous ModeSm state that was processed
 *
 * Returns the last ModeSm state ID that was handled by UpdateRFHardwareState().
 * Used for state change detection and debugging.
 *
 * @return ModeSm_StateId The previous mode state machine state
 */
ModeSm_StateId GetRFHardwarePreviousState(void){
    return previousRadioState;
}

/**
 * @brief Get the current RF hardware state
 *
 * Returns the current RF hardware configuration state. This may differ from
 * the ModeSm state as multiple mode states can map to the same hardware state.
 *
 * @return RFHardwareState Current hardware state (RFReceive, RFTransmit, RFCWMark, etc.)
 */
RFHardwareState GetRFHardwareState(void){
    return rfHardwareState;
}

/**
 * @brief Execute hardware configuration changes for a new RF state
 *
 * Implements the detailed hardware sequencing required to transition into a new
 * RF hardware state. Follows state transition diagrams in T41_V12_board_api.drawio.
 *
 * The function performs carefully ordered operations to ensure safe transitions:
 * - When entering RFReceive: Power down TX path first, then enable RX path
 * - When entering RFTransmit/RFCWMark: Disable RX path first, then configure TX
 * - Includes appropriate delays for relay settling and PIN diode switching
 *
 * Special optimization: Transitions between RFCWMark and RFCWSpace only toggle
 * the CW carrier on/off without reconfiguring the entire TX chain.
 *
 * @param newState The target RF hardware state to configure
 *
 * @note If newState matches the previous state, only updates tune state (frequency)
 * @note Uses MyDelay() for hardware settling times (relay: 50ms typical)
 */
void HandleRFHardwareStateChange(RFHardwareState newState){
    if (newState == oldrfHardwareState){
        UpdateTuneState();
        return;
    }
    // Following the state diagrams in T41_V12_board_api.drawio, implement the actions
    // required to enter the new state.
    switch (newState){
        case RFReceive:{
            // First, do things that reduce the transmitted power

            // Set cwState to LO
            CWoff();
            // Set clockEnableCW to LO
            DisableCWVFOOutput();
            SetTXAttenuation(31.5);
            TXBypassBPF(); // BPF out of TX path
            SelectXVTR();  // Shunt the TX path to nothing
            Bypass100WPA(); // always bypassed
            // Wait to make sure all the above have happened
            MyDelay(50);
            
            // Now, switch in the receive path hardware
            // Set frequency
            RXSelectBPF(); // BPF in to RX path
            UpdateTuneState();
            // Set GPA state to appropriate value
            SetRXAttenuation( ED.RAtten[ED.currentBand[ED.activeVFO]] );
            // Set driveCurrentSSB_mA to appropriate value
            // > This does not change after initialization, so do nothing
            // Set clockEnableSSB to HI (SSB)
            EnableSSBVFOOutput();
            SelectTXSSBModulation();
            // Make sure calFeedbackState is LO
            DisableCalFeedback();
            // Wait to make sure all these changes have happened
            MyDelay(50);
            // Set rxtxState to LO (RX)
            SelectRXMode();
            // Wait for the relay to switch
            MyDelay(50);
            SetTXAttenuation( ED.XAttenSSB[ED.currentBand[ED.activeVFO]] );
            break;
        }
        case RFTransmit:{
            // Get all the receive hardware out of the path
            RXBypassBPF(); // BPF out of RX path
            // Set calFeedbackState to LO
            DisableCalFeedback();
            MyDelay(50);

            // Start configuring the transmit chain
            // Set GPB state to appropriate value
            SetTXAttenuation( ED.XAttenSSB[ED.currentBand[ED.activeVFO]] );
            // Set clockEnableCW to LO
            DisableCWVFOOutput();
            // Set cwState to LO
            CWoff();
            // Set frequencySSB_Hz to the TXRX frequency
            //SetSSBVFOFrequency( GetTXRXFreq_dHz() );
            UpdateTuneState();
            // Set driveCurrentSSB_mA to appropriate value
            // > This does not change after initialization, so do nothing
            // Set clockEnableSSB to HI
            EnableSSBVFOOutput();
            // Set modulationState to HI (SSB)
            SelectTXSSBModulation();
            
            TXSelectBPF(); // BPF in to TX path
            BypassXVTR();  // Bypass XVTR
            Bypass100WPA(); // always bypassed

            MyDelay(50);
            // Set rxtxState to HI (TX)
            SelectTXMode();
            
            break;
        }
        case RFCWMark:{
            // If we come from the RFCWSpace state, we only have to change one thing
            if (oldrfHardwareState != RFCWSpace){
                RXBypassBPF(); // BPF out of RX path
                // Set calFeedbackState to LO
                DisableCalFeedback();
                // Set GPB state to appropriate value
                SetTXAttenuation( ED.XAttenCW[ED.currentBand[ED.activeVFO]] );
                // Set clockEnableSSB to LO
                DisableSSBVFOOutput();
                // Set frequencyCW_Hz to appropriate value
                //SetCWVFOFrequency( GetCWTXFreq_dHz() );
                UpdateTuneState();
                // Set driveCurrentCW_mA to appropriate value
                // > This does not change after initialization, so do nothing
                // Set clockEnableCW to HI
                EnableCWVFOOutput();
                // Set modulationState to LO (CW)
                SelectTXCWModulation();
                TXSelectBPF(); // BPF in to TX path
                BypassXVTR();  // Bypass XVTR
                Bypass100WPA(); // always bypassed
                // Set rxtxState to HI (TX)
                SelectTXMode();
                // Potential issue here if we don't wait for the relay to switch before
                // we turn the CW signal on.
                MyDelay(50);
            }
            // Set cwState to HI
            CWon();
            break;
        }
        case RFCWSpace:{
            // If we come from the RFCWMark state, we only have to change one thing
            if (oldrfHardwareState != RFCWMark){
                RXBypassBPF(); // BPF out of RX path
                // Set calFeedbackState to LO
                DisableCalFeedback();
                // Set GPB state to appropriate value
                SetTXAttenuation( ED.XAttenCW[ED.currentBand[ED.activeVFO]] );
                // Set clockEnableSSB to LO
                DisableSSBVFOOutput();
                // Set frequencyCW_Hz to appropriate value
                //SetCWVFOFrequency( GetCWTXFreq_dHz() );
                UpdateTuneState();
                // Set driveCurrentCW_mA to appropriate value
                // > This does not change after initialization, so do nothing
                // Set clockEnableCW to HI
                EnableCWVFOOutput();
                // Set modulationState to LO (CW)
                SelectTXCWModulation();
                TXSelectBPF(); // BPF in to TX path
                BypassXVTR();  // Bypass XVTR
                Bypass100WPA(); // always bypassed
                // Set rxtxState to HI (TX)
                SelectTXMode();
            }
            // Set cwState to LO
            CWoff();
            break;
        }
        case RFCalReceiveIQ:{
            
            // Turn these off just in case we somehow entered from CW Transmit Mode
            // Set cwState to LO
            CWoff();
            // Set clockEnableCW to LO
            DisableCWVFOOutput();
            SetTXAttenuation(31.5);
            TXBypassBPF(); // BPF out of TX path
            SelectXVTR();  // Shunt the TX path to nothing
            Bypass100WPA(); // always bypassed
            MyDelay(50);

            // Now, switch in the receive path hardware
            // Set frequency
            RXSelectBPF(); // BPF in to RX path
            UpdateTuneState();
            // Set GPA state to appropriate value
            SetRXAttenuation( 31.5 );
            // Set driveCurrentSSB_mA to appropriate value
            // > This does not change after initialization, so do nothing
            // Set clockEnableSSB to HI (SSB)
            EnableSSBVFOOutput();
            SelectTXCWModulation();
            // Make sure calFeedbackState is HI
            EnableCalFeedback();
            // Wait to make sure all these changes have happened
            MyDelay(50);
            // Set rxtxState to LO (RX)
            SelectRXMode();
            
            // Set clockEnableCW to HI
            EnableCWVFOOutput();
            // Set cwState to HI
            CWon();

            // Set the zoom for the FFT to 1:
            ED.spectrum_zoom = 0;
            ZoomFFTPrep(ED.spectrum_zoom, &RXfilters);
            break;
        }
        case RFInvalid:{
            Debug("Asked to handle RFInvalid state, doing nothing.");
            break;
        }
    }
    oldrfHardwareState = newState;
}

/**
 * @brief Update RF hardware based on current ModeSm state
 *
 * Main entry point called from the Loop to synchronize RF hardware with the
 * current radio operating mode. Translates ModeSm states to RF hardware states:
 *
 * ModeSm State              -> RF Hardware State
 * ----------------------       -----------------
 * SSB_RECEIVE               -> RFReceive
 * CW_RECEIVE                -> RFReceive
 * SSB_TRANSMIT              -> RFTransmit
 * CW_TRANSMIT_*_MARK        -> RFCWMark
 * CW_TRANSMIT_*_SPACE       -> RFCWSpace
 *
 * Performs state change detection to avoid redundant hardware reconfiguration.
 * If only frequency has changed (same ModeSm state), updates tune state only.
 *
 * @note Should be called in every iteration of the main program loop
 * @see HandleRFHardwareStateChange() for actual hardware configuration
 * @see UpdateTuneState() for frequency management
 */
void UpdateRFHardwareState(void){
    if (modeSM.state_id == previousRadioState){
        // Already in this state, no need to change RF hardware, though the
        // tuning might have changed.
        UpdateTuneState();
        return;
    }
    // Several transceiver states map to the same RF board state. Handle this mapping
    // and call the function to handle the new RF board state.
    switch (modeSM.state_id){
        case (ModeSm_StateId_CALIBRATE_FREQUENCY):
        case (ModeSm_StateId_CALIBRATE_TX_IQ_SPACE):
        case (ModeSm_StateId_CW_RECEIVE):
        case (ModeSm_StateId_SSB_RECEIVE):{
            rfHardwareState = RFReceive;
            break;
        }
        case (ModeSm_StateId_CALIBRATE_TX_IQ_MARK):
        case (ModeSm_StateId_SSB_TRANSMIT):{
            rfHardwareState = RFTransmit;
            break;
        }
        case (ModeSm_StateId_CW_TRANSMIT_DIT_MARK):
        case (ModeSm_StateId_CW_TRANSMIT_DAH_MARK):
        case (ModeSm_StateId_CW_TRANSMIT_MARK):{
            rfHardwareState = RFCWMark;
            break;
        }
        case (ModeSm_StateId_CW_TRANSMIT_SPACE):
        case (ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE):
        case (ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT):{
            rfHardwareState = RFCWSpace;
            break;
        }
        case (ModeSm_StateId_CALIBRATE_RX_IQ):{
            rfHardwareState = RFCalReceiveIQ;
            break;
        }
        case (ModeSm_StateId_CALIBRATE_CW_PA):{
            Debug("Entered hardware cal power state");
            break;
        }
        //case (ModeSm_StateId_CALIBRATE_SSB_PA):{
        //    break;
        //}
        default:{
            Debug("Unhandled modeSM.state_id state in UpdateRFHardwareState!");
            char strbuf[10];
            sprintf(strbuf, "> %lu",(uint32_t)modeSM.state_id);
            Debug(strbuf);
            break;
        }
    }
    HandleRFHardwareStateChange(rfHardwareState);
    previousRadioState = modeSM.state_id;
}

// Functions we need to invoke when tuning for calibration
void TuneForReceiveIQCalibration(void){
    ED.fineTuneFreq_Hz[ED.currentBand[ED.activeVFO]] = 0;
    int64_t band_center = (bands[ED.currentBand[ED.activeVFO]].fBandHigh_Hz + 
                            bands[ED.currentBand[ED.activeVFO]].fBandLow_Hz)/2;
    SetSSBVFOFrequency( band_center*100 );
    // Set the CW signal to be on the opposite side of the LO from the
    // nominal tune frequency and minimize the leakage of that signal
    // into the nominal tune frequency bins
    if (bands[ED.currentBand[ED.activeVFO]].mode == LSB){
        SetCWVFOFrequency( (band_center + SR[SampleRate].rate/4)*100 );
    } else {
        SetCWVFOFrequency( (band_center - SR[SampleRate].rate/4)*100 );
    }
}

/**
 * @brief Execute VFO frequency changes for a new tune state
 *
 * Configures the VFO frequencies based on operating mode and TX/RX state.
 * The SDR architecture uses baseband processing at SampleRate/4, requiring
 * different VFO frequencies for RX vs TX and SSB vs CW modes:
 *
 * Frequency Calculations:
 * - CW/SSB Receive:  RXfreq = centerFreq_Hz - fineTuneFreq_Hz - SampleRate/4
 * - SSB Transmit:    TXfreq = centerFreq_Hz
 * - CW Transmit:     TXfreq = centerFreq_Hz - fineTuneFreq_Hz - SampleRate/4 -/+ CWToneOffset
 *
 * Also updates band-dependent hardware:
 * - LPF band selection (harmonic filtering)
 * - BPF band selection (image rejection)
 * - Antenna routing
 * - FIR filter coefficients
 *
 * @param tuneState The target tune state (TuneReceive, TuneSSBTX, or TuneCWTX)
 *
 * @note Ignores TuneInvalid state
 * @note Uses activeVFO to determine which VFO settings to apply
 */
void HandleTuneState(TuneState tuneState){
    if (tuneState == TuneInvalid) return;
    
    SelectLPFBand(ED.currentBand[ED.activeVFO]);
    SelectBPFBand(ED.currentBand[ED.activeVFO]);
    SelectAntenna(ED.antennaSelection[ED.currentBand[ED.activeVFO]]);
    UpdateFIRFilterMask(&RXfilters);
    switch (tuneState){
        case TuneReceive:{
            // CW/SSB Receive:  RXfreq = centerFreq_Hz - fineTuneFreq_Hz - SampleRate/4
            int64_t newFreq = ED.centerFreq_Hz[ED.activeVFO]*100;
            SetSSBVFOFrequency( newFreq );
            break;
        }
        case TuneSSBTX:{
            // SSB Transmit:    TXfreq = centerFreq_Hz
            int64_t newFreq = GetTXRXFreq_dHz();
            SetSSBVFOFrequency( newFreq );
            break;
        }
        case TuneCWTX:{
            // CW Transmit:     TXfreq = centerFreq_Hz - fineTuneFreq_Hz - SampleRate/4 -/+ CWToneOffset
            int64_t newFreq = GetCWTXFreq_dHz();
            SetCWVFOFrequency( newFreq );
            break;
        }
        case (TuneCalReceiveIQ):{
            TuneForReceiveIQCalibration();
            break;
        }
        default:
            break;
    }
}

/**
 * @brief Update tune state based on current ModeSm state
 *
 * Translates the current ModeSm operating mode into the appropriate tune state
 * for VFO frequency management. Maps as follows:
 *
 * ModeSm State              -> Tune State
 * ----------------------       -----------
 * SSB_RECEIVE               -> TuneReceive
 * CW_RECEIVE                -> TuneReceive
 * SSB_TRANSMIT              -> TuneSSBTX
 * CW_TRANSMIT_* (all)       -> TuneCWTX
 *
 * After determining the tune state, calls HandleTuneState() to execute
 * the actual frequency changes and band-dependent hardware updates.
 *
 * @note Called both when ModeSm state changes and when frequency is adjusted
 * @see HandleTuneState() for actual VFO frequency configuration
 */
void UpdateTuneState(void){
    switch (modeSM.state_id){
        case (ModeSm_StateId_CALIBRATE_TX_IQ_SPACE):
        case (ModeSm_StateId_CALIBRATE_FREQUENCY):
        case (ModeSm_StateId_CW_RECEIVE):
        case (ModeSm_StateId_SSB_RECEIVE):{
            tuneState = TuneReceive;
            break;
        }
        case (ModeSm_StateId_CALIBRATE_TX_IQ_MARK):
        case (ModeSm_StateId_SSB_TRANSMIT):{
            tuneState = TuneSSBTX;
            break;
        }
        case (ModeSm_StateId_CW_TRANSMIT_DIT_MARK):
        case (ModeSm_StateId_CW_TRANSMIT_DAH_MARK):
        case (ModeSm_StateId_CW_TRANSMIT_MARK):
        case (ModeSm_StateId_CW_TRANSMIT_SPACE):
        case (ModeSm_StateId_CW_TRANSMIT_KEYER_SPACE):
        case (ModeSm_StateId_CW_TRANSMIT_KEYER_WAIT):{
            tuneState = TuneCWTX;
            break;
        }
        case (ModeSm_StateId_CALIBRATE_RX_IQ):{
            tuneState = TuneCalReceiveIQ;
            break;
        }
        //case (ModeSm_StateId_CALIBRATE_TX_IQ):
        //case (ModeSm_StateId_CALIBRATE_CW_PA):
        //case (ModeSm_StateId_CALIBRATE_SSB_PA):{
        //    break;
        //}

        default:{
            Debug("Unhandled modeSM.state_id state in UpdateTuneState!");
            char strbuf[10];
            sprintf(strbuf, "> %lu",(uint32_t)modeSM.state_id);
            Debug(strbuf);
            break;
        }
    }
    HandleTuneState(tuneState);
}