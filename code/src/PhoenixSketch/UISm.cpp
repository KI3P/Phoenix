// Autogenerated with StateSmith 0.17.5+6ec341a3c93edf598f2ca7c31f61af85857928de.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Whatever you put in this `FileTop` section will end up 
// being printed at the top of every generated code file.

#include "UISm.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
    

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(UISm* sm, UISm_StateId desired_state);

static void ROOT_enter(UISm* sm);

static void CALIBRATE_DISPLAYS_enter(UISm* sm);

static void CALIBRATE_DISPLAYS_exit(UISm* sm);

static void CALIBRATE_DISPLAYS_select(UISm* sm);

static void CALIBRATE_CW_PA_DISPLAY_enter(UISm* sm);

static void CALIBRATE_CW_PA_DISPLAY_exit(UISm* sm);

static void CALIBRATE_FREQUENCY_DISPLAY_enter(UISm* sm);

static void CALIBRATE_FREQUENCY_DISPLAY_exit(UISm* sm);

static void CALIBRATE_RX_IQ_DISPLAY_enter(UISm* sm);

static void CALIBRATE_RX_IQ_DISPLAY_exit(UISm* sm);

static void CALIBRATE_SSB_PA_DISPLAY_enter(UISm* sm);

static void CALIBRATE_SSB_PA_DISPLAY_exit(UISm* sm);

static void CALIBRATE_TX_IQ_DISPLAY_enter(UISm* sm);

static void CALIBRATE_TX_IQ_DISPLAY_exit(UISm* sm);

static void CALIBRATE_MENU_DISPLAY_enter(UISm* sm);

static void CALIBRATE_MENU_DISPLAY_exit(UISm* sm);

static void CALIBRATE_CANCEL_enter(UISm* sm);

static void CALIBRATE_CANCEL_exit(UISm* sm);

static void CALIBRATE_CANCEL_menu_dec(UISm* sm);

static void CALIBRATE_CANCEL_menu_inc(UISm* sm);

static void CALIBRATE_CW_PA_enter(UISm* sm);

static void CALIBRATE_CW_PA_exit(UISm* sm);

static void CALIBRATE_CW_PA_menu_dec(UISm* sm);

static void CALIBRATE_CW_PA_menu_inc(UISm* sm);

static void CALIBRATE_CW_PA_select(UISm* sm);

static void CALIBRATE_FREQUENCY_enter(UISm* sm);

static void CALIBRATE_FREQUENCY_exit(UISm* sm);

static void CALIBRATE_FREQUENCY_menu_dec(UISm* sm);

static void CALIBRATE_FREQUENCY_menu_inc(UISm* sm);

static void CALIBRATE_FREQUENCY_select(UISm* sm);

static void CALIBRATE_RX_IQ_enter(UISm* sm);

static void CALIBRATE_RX_IQ_exit(UISm* sm);

static void CALIBRATE_RX_IQ_menu_dec(UISm* sm);

static void CALIBRATE_RX_IQ_menu_inc(UISm* sm);

static void CALIBRATE_RX_IQ_select(UISm* sm);

static void CALIBRATE_SSB_PA_enter(UISm* sm);

static void CALIBRATE_SSB_PA_exit(UISm* sm);

static void CALIBRATE_SSB_PA_menu_dec(UISm* sm);

static void CALIBRATE_SSB_PA_menu_inc(UISm* sm);

static void CALIBRATE_SSB_PA_select(UISm* sm);

static void CALIBRATE_TX_IQ_enter(UISm* sm);

static void CALIBRATE_TX_IQ_exit(UISm* sm);

static void CALIBRATE_TX_IQ_menu_dec(UISm* sm);

static void CALIBRATE_TX_IQ_menu_inc(UISm* sm);

static void CALIBRATE_TX_IQ_select(UISm* sm);

static void HOME_enter(UISm* sm);

static void HOME_exit(UISm* sm);

static void HOME_menu(UISm* sm);

static void MAIN_MENU_DISPLAY_enter(UISm* sm);

static void MAIN_MENU_DISPLAY_exit(UISm* sm);

static void MAIN_MENU_AUDIO_enter(UISm* sm);

static void MAIN_MENU_AUDIO_exit(UISm* sm);

static void MAIN_MENU_AUDIO_menu_dec(UISm* sm);

static void MAIN_MENU_AUDIO_menu_inc(UISm* sm);

static void MAIN_MENU_CALIBRATE_enter(UISm* sm);

static void MAIN_MENU_CALIBRATE_exit(UISm* sm);

static void MAIN_MENU_CALIBRATE_menu_dec(UISm* sm);

static void MAIN_MENU_CALIBRATE_menu_inc(UISm* sm);

static void MAIN_MENU_CALIBRATE_select(UISm* sm);

static void MAIN_MENU_CANCEL_enter(UISm* sm);

static void MAIN_MENU_CANCEL_exit(UISm* sm);

static void MAIN_MENU_CANCEL_menu_dec(UISm* sm);

static void MAIN_MENU_CANCEL_menu_inc(UISm* sm);

static void MAIN_MENU_CANCEL_select(UISm* sm);

static void MAIN_MENU_CW_enter(UISm* sm);

static void MAIN_MENU_CW_exit(UISm* sm);

static void MAIN_MENU_CW_menu_dec(UISm* sm);

static void MAIN_MENU_CW_menu_inc(UISm* sm);

static void MAIN_MENU_RF_enter(UISm* sm);

static void MAIN_MENU_RF_exit(UISm* sm);

static void MAIN_MENU_RF_menu_dec(UISm* sm);

static void MAIN_MENU_RF_menu_inc(UISm* sm);

static void MAIN_MENU_RF_select(UISm* sm);

static void RF_MENU_DISPLAY_enter(UISm* sm);

static void RF_MENU_DISPLAY_exit(UISm* sm);

static void RF_ADJUST_RX_GAIN_enter(UISm* sm);

static void RF_ADJUST_RX_GAIN_exit(UISm* sm);

static void RF_ADJUST_RX_GAIN_menu_dec(UISm* sm);

static void RF_ADJUST_RX_GAIN_menu_inc(UISm* sm);

static void RF_ADJUST_RX_GAIN_select(UISm* sm);

static void RF_ADJUST_SCALE_enter(UISm* sm);

static void RF_ADJUST_SCALE_exit(UISm* sm);

static void RF_ADJUST_SCALE_menu_dec(UISm* sm);

static void RF_ADJUST_SCALE_menu_inc(UISm* sm);

static void RF_ADJUST_SCALE_select(UISm* sm);

static void RF_ADJUST_TX_GAIN_enter(UISm* sm);

static void RF_ADJUST_TX_GAIN_exit(UISm* sm);

static void RF_ADJUST_TX_GAIN_menu_dec(UISm* sm);

static void RF_ADJUST_TX_GAIN_menu_inc(UISm* sm);

static void RF_ADJUST_TX_GAIN_select(UISm* sm);

static void RF_CANCEL_enter(UISm* sm);

static void RF_CANCEL_exit(UISm* sm);

static void RF_CANCEL_menu_dec(UISm* sm);

static void RF_CANCEL_menu_inc(UISm* sm);

static void RF_CANCEL_select(UISm* sm);

static void RF_SELECT_100WPA_enter(UISm* sm);

static void RF_SELECT_100WPA_exit(UISm* sm);

static void RF_SELECT_100WPA_menu_dec(UISm* sm);

static void RF_SELECT_100WPA_menu_inc(UISm* sm);

static void SHOW_VALUE_enter(UISm* sm);

static void SHOW_VALUE_exit(UISm* sm);

static void SHOW_VALUE_menu_dec(UISm* sm);

static void SHOW_VALUE_menu_inc(UISm* sm);

static void SHOW_VALUE_select(UISm* sm);

static void SPLASH_enter(UISm* sm);

static void SPLASH_exit(UISm* sm);

static void SPLASH_do(UISm* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void UISm_ctor(UISm* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void UISm_start(UISm* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(SPLASH)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SPLASH`.
            SPLASH_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void UISm_dispatch_event(UISm* sm, UISm_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: UISm
        case UISm_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: CALIBRATE_DISPLAYS
        case UISm_StateId_CALIBRATE_DISPLAYS:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_CW_PA_DISPLAY
        case UISm_StateId_CALIBRATE_CW_PA_DISPLAY:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_FREQUENCY_DISPLAY
        case UISm_StateId_CALIBRATE_FREQUENCY_DISPLAY:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_RX_IQ_DISPLAY
        case UISm_StateId_CALIBRATE_RX_IQ_DISPLAY:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_SSB_PA_DISPLAY
        case UISm_StateId_CALIBRATE_SSB_PA_DISPLAY:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_TX_IQ_DISPLAY
        case UISm_StateId_CALIBRATE_TX_IQ_DISPLAY:
            switch (event_id)
            {
                case UISm_EventId_SELECT: CALIBRATE_DISPLAYS_select(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_MENU_DISPLAY
        case UISm_StateId_CALIBRATE_MENU_DISPLAY:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: CALIBRATE_CANCEL
        case UISm_StateId_CALIBRATE_CANCEL:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: CALIBRATE_CANCEL_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: CALIBRATE_CANCEL_menu_dec(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_CW_PA
        case UISm_StateId_CALIBRATE_CW_PA:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: CALIBRATE_CW_PA_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: CALIBRATE_CW_PA_menu_inc(sm); break;
                case UISm_EventId_SELECT: CALIBRATE_CW_PA_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_FREQUENCY
        case UISm_StateId_CALIBRATE_FREQUENCY:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: CALIBRATE_FREQUENCY_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: CALIBRATE_FREQUENCY_menu_dec(sm); break;
                case UISm_EventId_SELECT: CALIBRATE_FREQUENCY_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_RX_IQ
        case UISm_StateId_CALIBRATE_RX_IQ:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: CALIBRATE_RX_IQ_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: CALIBRATE_RX_IQ_menu_inc(sm); break;
                case UISm_EventId_SELECT: CALIBRATE_RX_IQ_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_SSB_PA
        case UISm_StateId_CALIBRATE_SSB_PA:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: CALIBRATE_SSB_PA_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: CALIBRATE_SSB_PA_menu_inc(sm); break;
                case UISm_EventId_SELECT: CALIBRATE_SSB_PA_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: CALIBRATE_TX_IQ
        case UISm_StateId_CALIBRATE_TX_IQ:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: CALIBRATE_TX_IQ_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: CALIBRATE_TX_IQ_menu_inc(sm); break;
                case UISm_EventId_SELECT: CALIBRATE_TX_IQ_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: HOME
        case UISm_StateId_HOME:
            switch (event_id)
            {
                case UISm_EventId_MENU: HOME_menu(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MAIN_MENU_DISPLAY
        case UISm_StateId_MAIN_MENU_DISPLAY:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: MAIN_MENU_AUDIO
        case UISm_StateId_MAIN_MENU_AUDIO:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: MAIN_MENU_AUDIO_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: MAIN_MENU_AUDIO_menu_inc(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MAIN_MENU_CALIBRATE
        case UISm_StateId_MAIN_MENU_CALIBRATE:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: MAIN_MENU_CALIBRATE_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: MAIN_MENU_CALIBRATE_menu_inc(sm); break;
                case UISm_EventId_SELECT: MAIN_MENU_CALIBRATE_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MAIN_MENU_CANCEL
        case UISm_StateId_MAIN_MENU_CANCEL:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: MAIN_MENU_CANCEL_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: MAIN_MENU_CANCEL_menu_dec(sm); break;
                case UISm_EventId_SELECT: MAIN_MENU_CANCEL_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MAIN_MENU_CW
        case UISm_StateId_MAIN_MENU_CW:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: MAIN_MENU_CW_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: MAIN_MENU_CW_menu_inc(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: MAIN_MENU_RF
        case UISm_StateId_MAIN_MENU_RF:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: MAIN_MENU_RF_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: MAIN_MENU_RF_menu_dec(sm); break;
                case UISm_EventId_SELECT: MAIN_MENU_RF_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RF_MENU_DISPLAY
        case UISm_StateId_RF_MENU_DISPLAY:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: RF_ADJUST_RX_GAIN
        case UISm_StateId_RF_ADJUST_RX_GAIN:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: RF_ADJUST_RX_GAIN_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: RF_ADJUST_RX_GAIN_menu_dec(sm); break;
                case UISm_EventId_SELECT: RF_ADJUST_RX_GAIN_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RF_ADJUST_SCALE
        case UISm_StateId_RF_ADJUST_SCALE:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: RF_ADJUST_SCALE_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: RF_ADJUST_SCALE_menu_inc(sm); break;
                case UISm_EventId_SELECT: RF_ADJUST_SCALE_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RF_ADJUST_TX_GAIN
        case UISm_StateId_RF_ADJUST_TX_GAIN:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: RF_ADJUST_TX_GAIN_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: RF_ADJUST_TX_GAIN_menu_inc(sm); break;
                case UISm_EventId_SELECT: RF_ADJUST_TX_GAIN_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RF_CANCEL
        case UISm_StateId_RF_CANCEL:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: RF_CANCEL_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: RF_CANCEL_menu_dec(sm); break;
                case UISm_EventId_SELECT: RF_CANCEL_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: RF_SELECT_100WPA
        case UISm_StateId_RF_SELECT_100WPA:
            switch (event_id)
            {
                case UISm_EventId_MENU_DEC: RF_SELECT_100WPA_menu_dec(sm); break;
                case UISm_EventId_MENU_INC: RF_SELECT_100WPA_menu_inc(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SHOW_VALUE
        case UISm_StateId_SHOW_VALUE:
            switch (event_id)
            {
                case UISm_EventId_MENU_INC: SHOW_VALUE_menu_inc(sm); break;
                case UISm_EventId_MENU_DEC: SHOW_VALUE_menu_dec(sm); break;
                case UISm_EventId_SELECT: SHOW_VALUE_select(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: SPLASH
        case UISm_StateId_SPLASH:
            switch (event_id)
            {
                case UISm_EventId_DO: SPLASH_do(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(UISm* sm, UISm_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case UISm_StateId_CALIBRATE_DISPLAYS: CALIBRATE_DISPLAYS_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_CW_PA_DISPLAY: CALIBRATE_CW_PA_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_FREQUENCY_DISPLAY: CALIBRATE_FREQUENCY_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_RX_IQ_DISPLAY: CALIBRATE_RX_IQ_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_SSB_PA_DISPLAY: CALIBRATE_SSB_PA_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_TX_IQ_DISPLAY: CALIBRATE_TX_IQ_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_MENU_DISPLAY: CALIBRATE_MENU_DISPLAY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_CANCEL: CALIBRATE_CANCEL_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_CW_PA: CALIBRATE_CW_PA_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_FREQUENCY: CALIBRATE_FREQUENCY_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_RX_IQ: CALIBRATE_RX_IQ_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_SSB_PA: CALIBRATE_SSB_PA_exit(sm); break;
            
            case UISm_StateId_CALIBRATE_TX_IQ: CALIBRATE_TX_IQ_exit(sm); break;
            
            case UISm_StateId_HOME: HOME_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_DISPLAY: MAIN_MENU_DISPLAY_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_AUDIO: MAIN_MENU_AUDIO_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_CALIBRATE: MAIN_MENU_CALIBRATE_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_CANCEL: MAIN_MENU_CANCEL_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_CW: MAIN_MENU_CW_exit(sm); break;
            
            case UISm_StateId_MAIN_MENU_RF: MAIN_MENU_RF_exit(sm); break;
            
            case UISm_StateId_RF_MENU_DISPLAY: RF_MENU_DISPLAY_exit(sm); break;
            
            case UISm_StateId_RF_ADJUST_RX_GAIN: RF_ADJUST_RX_GAIN_exit(sm); break;
            
            case UISm_StateId_RF_ADJUST_SCALE: RF_ADJUST_SCALE_exit(sm); break;
            
            case UISm_StateId_RF_ADJUST_TX_GAIN: RF_ADJUST_TX_GAIN_exit(sm); break;
            
            case UISm_StateId_RF_CANCEL: RF_CANCEL_exit(sm); break;
            
            case UISm_StateId_RF_SELECT_100WPA: RF_SELECT_100WPA_exit(sm); break;
            
            case UISm_StateId_SHOW_VALUE: SHOW_VALUE_exit(sm); break;
            
            case UISm_StateId_SPLASH: SPLASH_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_DISPLAYS
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_DISPLAYS_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}

static void CALIBRATE_DISPLAYS_exit(UISm* sm)
{
    // CALIBRATE_DISPLAYS behavior
    // uml: exit / { TriggerCalibrateExit(); }
    {
        // Step 1: execute action `TriggerCalibrateExit();`
        TriggerCalibrateExit();
    } // end of behavior for CALIBRATE_DISPLAYS
    
    sm->state_id = UISm_StateId_ROOT;
}

static void CALIBRATE_DISPLAYS_select(UISm* sm)
{
    // CALIBRATE_DISPLAYS behavior
    // uml: SELECT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_DISPLAYS
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_CW_PA_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_CW_PA_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_CW_PA_DISPLAY;
    
    // CALIBRATE_CW_PA_DISPLAY behavior
    // uml: enter / { TriggerCalibrateCWPA(); }
    {
        // Step 1: execute action `TriggerCalibrateCWPA();`
        TriggerCalibrateCWPA();
    } // end of behavior for CALIBRATE_CW_PA_DISPLAY
}

static void CALIBRATE_CW_PA_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_FREQUENCY_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_FREQUENCY_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_FREQUENCY_DISPLAY;
    
    // CALIBRATE_FREQUENCY_DISPLAY behavior
    // uml: enter / { TriggerCalibrateFrequency(); }
    {
        // Step 1: execute action `TriggerCalibrateFrequency();`
        TriggerCalibrateFrequency();
    } // end of behavior for CALIBRATE_FREQUENCY_DISPLAY
}

static void CALIBRATE_FREQUENCY_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_RX_IQ_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_RX_IQ_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_RX_IQ_DISPLAY;
    
    // CALIBRATE_RX_IQ_DISPLAY behavior
    // uml: enter / { TriggerCalibrateRXIQ(); }
    {
        // Step 1: execute action `TriggerCalibrateRXIQ();`
        TriggerCalibrateRXIQ();
    } // end of behavior for CALIBRATE_RX_IQ_DISPLAY
}

static void CALIBRATE_RX_IQ_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_SSB_PA_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_SSB_PA_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_SSB_PA_DISPLAY;
    
    // CALIBRATE_SSB_PA_DISPLAY behavior
    // uml: enter / { TriggerCalibrateSSBPA(); }
    {
        // Step 1: execute action `TriggerCalibrateSSBPA();`
        TriggerCalibrateSSBPA();
    } // end of behavior for CALIBRATE_SSB_PA_DISPLAY
}

static void CALIBRATE_SSB_PA_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_TX_IQ_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_TX_IQ_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_TX_IQ_DISPLAY;
    
    // CALIBRATE_TX_IQ_DISPLAY behavior
    // uml: enter / { TriggerCalibrateTXIQ(); }
    {
        // Step 1: execute action `TriggerCalibrateTXIQ();`
        TriggerCalibrateTXIQ();
    } // end of behavior for CALIBRATE_TX_IQ_DISPLAY
}

static void CALIBRATE_TX_IQ_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_DISPLAYS;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_MENU_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_MENU_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_MENU_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_CANCEL
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_CANCEL_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_CANCEL;
}

static void CALIBRATE_CANCEL_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_CANCEL_menu_dec(UISm* sm)
{
    // CALIBRATE_CANCEL behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_SSB_PA)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_SSB_PA`.
        CALIBRATE_SSB_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_CANCEL
    
    // No ancestor handles this event.
}

static void CALIBRATE_CANCEL_menu_inc(UISm* sm)
{
    // CALIBRATE_CANCEL behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_FREQUENCY)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_FREQUENCY`.
        CALIBRATE_FREQUENCY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_CANCEL
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_CW_PA
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_CW_PA_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_CW_PA;
}

static void CALIBRATE_CW_PA_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_CW_PA_menu_dec(UISm* sm)
{
    // CALIBRATE_CW_PA behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_TX_IQ)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_CW_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ`.
        CALIBRATE_TX_IQ_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_CW_PA
    
    // No ancestor handles this event.
}

static void CALIBRATE_CW_PA_menu_inc(UISm* sm)
{
    // CALIBRATE_CW_PA behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_SSB_PA)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_CW_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_SSB_PA`.
        CALIBRATE_SSB_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_CW_PA
    
    // No ancestor handles this event.
}

static void CALIBRATE_CW_PA_select(UISm* sm)
{
    // CALIBRATE_CW_PA behavior
    // uml: SELECT TransitionTo(CALIBRATE_CW_PA_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CW_PA_DISPLAY`.
        CALIBRATE_DISPLAYS_enter(sm);
        CALIBRATE_CW_PA_DISPLAY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_CW_PA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_FREQUENCY
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_FREQUENCY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_FREQUENCY;
}

static void CALIBRATE_FREQUENCY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_FREQUENCY_menu_dec(UISm* sm)
{
    // CALIBRATE_FREQUENCY behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_CANCEL)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_FREQUENCY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CANCEL`.
        CALIBRATE_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_FREQUENCY
    
    // No ancestor handles this event.
}

static void CALIBRATE_FREQUENCY_menu_inc(UISm* sm)
{
    // CALIBRATE_FREQUENCY behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_RX_IQ)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_FREQUENCY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_RX_IQ`.
        CALIBRATE_RX_IQ_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_FREQUENCY
    
    // No ancestor handles this event.
}

static void CALIBRATE_FREQUENCY_select(UISm* sm)
{
    // CALIBRATE_FREQUENCY behavior
    // uml: SELECT TransitionTo(CALIBRATE_FREQUENCY_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_FREQUENCY_DISPLAY`.
        CALIBRATE_DISPLAYS_enter(sm);
        CALIBRATE_FREQUENCY_DISPLAY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_FREQUENCY
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_RX_IQ
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_RX_IQ_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_RX_IQ;
}

static void CALIBRATE_RX_IQ_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_RX_IQ_menu_dec(UISm* sm)
{
    // CALIBRATE_RX_IQ behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_FREQUENCY)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_RX_IQ_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_FREQUENCY`.
        CALIBRATE_FREQUENCY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_RX_IQ
    
    // No ancestor handles this event.
}

static void CALIBRATE_RX_IQ_menu_inc(UISm* sm)
{
    // CALIBRATE_RX_IQ behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_TX_IQ)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_RX_IQ_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ`.
        CALIBRATE_TX_IQ_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_RX_IQ
    
    // No ancestor handles this event.
}

static void CALIBRATE_RX_IQ_select(UISm* sm)
{
    // CALIBRATE_RX_IQ behavior
    // uml: SELECT TransitionTo(CALIBRATE_RX_IQ_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_RX_IQ_DISPLAY`.
        CALIBRATE_DISPLAYS_enter(sm);
        CALIBRATE_RX_IQ_DISPLAY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_RX_IQ
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_SSB_PA
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_SSB_PA_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_SSB_PA;
}

static void CALIBRATE_SSB_PA_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_SSB_PA_menu_dec(UISm* sm)
{
    // CALIBRATE_SSB_PA behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_CW_PA)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_SSB_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CW_PA`.
        CALIBRATE_CW_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_SSB_PA
    
    // No ancestor handles this event.
}

static void CALIBRATE_SSB_PA_menu_inc(UISm* sm)
{
    // CALIBRATE_SSB_PA behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_CANCEL)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_SSB_PA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CANCEL`.
        CALIBRATE_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_SSB_PA
    
    // No ancestor handles this event.
}

static void CALIBRATE_SSB_PA_select(UISm* sm)
{
    // CALIBRATE_SSB_PA behavior
    // uml: SELECT TransitionTo(CALIBRATE_SSB_PA_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_SSB_PA_DISPLAY`.
        CALIBRATE_DISPLAYS_enter(sm);
        CALIBRATE_SSB_PA_DISPLAY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_SSB_PA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CALIBRATE_TX_IQ
////////////////////////////////////////////////////////////////////////////////

static void CALIBRATE_TX_IQ_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_TX_IQ;
}

static void CALIBRATE_TX_IQ_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_CALIBRATE_MENU_DISPLAY;
}

static void CALIBRATE_TX_IQ_menu_dec(UISm* sm)
{
    // CALIBRATE_TX_IQ behavior
    // uml: MENU_DEC TransitionTo(CALIBRATE_RX_IQ)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_TX_IQ_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_RX_IQ`.
        CALIBRATE_RX_IQ_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_TX_IQ
    
    // No ancestor handles this event.
}

static void CALIBRATE_TX_IQ_menu_inc(UISm* sm)
{
    // CALIBRATE_TX_IQ behavior
    // uml: MENU_INC TransitionTo(CALIBRATE_CW_PA)
    {
        // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition).
        CALIBRATE_TX_IQ_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_CW_PA`.
        CALIBRATE_CW_PA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_TX_IQ
    
    // No ancestor handles this event.
}

static void CALIBRATE_TX_IQ_select(UISm* sm)
{
    // CALIBRATE_TX_IQ behavior
    // uml: SELECT TransitionTo(CALIBRATE_TX_IQ_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_TX_IQ_DISPLAY`.
        CALIBRATE_DISPLAYS_enter(sm);
        CALIBRATE_TX_IQ_DISPLAY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for CALIBRATE_TX_IQ
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HOME
////////////////////////////////////////////////////////////////////////////////

static void HOME_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_HOME;
    
    // HOME behavior
    // uml: enter / { clearScreen = true; }
    {
        // Step 1: execute action `clearScreen = true;`
        sm->vars.clearScreen = true;
    } // end of behavior for HOME
}

static void HOME_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}

static void HOME_menu(UISm* sm)
{
    // HOME behavior
    // uml: MENU TransitionTo(MAIN_MENU_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        HOME_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_DISPLAY`.
        MAIN_MENU_DISPLAY_enter(sm);
        
        // MAIN_MENU_DISPLAY.<InitialState> behavior
        // uml: TransitionTo(MAIN_MENU_RF)
        {
            // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `MAIN_MENU_RF`.
            MAIN_MENU_RF_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MAIN_MENU_DISPLAY.<InitialState>
    } // end of behavior for HOME
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_AUDIO
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_AUDIO_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_AUDIO;
}

static void MAIN_MENU_AUDIO_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_AUDIO_menu_dec(UISm* sm)
{
    // MAIN_MENU_AUDIO behavior
    // uml: MENU_DEC TransitionTo(MAIN_MENU_RF)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_AUDIO_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_RF`.
        MAIN_MENU_RF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_AUDIO
    
    // No ancestor handles this event.
}

static void MAIN_MENU_AUDIO_menu_inc(UISm* sm)
{
    // MAIN_MENU_AUDIO behavior
    // uml: MENU_INC TransitionTo(MAIN_MENU_CW)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_AUDIO_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CW`.
        MAIN_MENU_CW_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_AUDIO
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_CALIBRATE
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_CALIBRATE_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_CALIBRATE;
}

static void MAIN_MENU_CALIBRATE_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_CALIBRATE_menu_dec(UISm* sm)
{
    // MAIN_MENU_CALIBRATE behavior
    // uml: MENU_DEC TransitionTo(MAIN_MENU_CW)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CALIBRATE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CW`.
        MAIN_MENU_CW_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CALIBRATE
    
    // No ancestor handles this event.
}

static void MAIN_MENU_CALIBRATE_menu_inc(UISm* sm)
{
    // MAIN_MENU_CALIBRATE behavior
    // uml: MENU_INC TransitionTo(MAIN_MENU_CANCEL)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CALIBRATE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CANCEL`.
        MAIN_MENU_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CALIBRATE
    
    // No ancestor handles this event.
}

static void MAIN_MENU_CALIBRATE_select(UISm* sm)
{
    // MAIN_MENU_CALIBRATE behavior
    // uml: SELECT TransitionTo(CALIBRATE_MENU_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `CALIBRATE_MENU_DISPLAY`.
        CALIBRATE_MENU_DISPLAY_enter(sm);
        
        // CALIBRATE_MENU_DISPLAY.<InitialState> behavior
        // uml: TransitionTo(CALIBRATE_FREQUENCY)
        {
            // Step 1: Exit states until we reach `CALIBRATE_MENU_DISPLAY` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `CALIBRATE_FREQUENCY`.
            CALIBRATE_FREQUENCY_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for CALIBRATE_MENU_DISPLAY.<InitialState>
    } // end of behavior for MAIN_MENU_CALIBRATE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_CANCEL
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_CANCEL_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_CANCEL;
}

static void MAIN_MENU_CANCEL_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_CANCEL_menu_dec(UISm* sm)
{
    // MAIN_MENU_CANCEL behavior
    // uml: MENU_DEC TransitionTo(MAIN_MENU_CALIBRATE)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CALIBRATE`.
        MAIN_MENU_CALIBRATE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CANCEL
    
    // No ancestor handles this event.
}

static void MAIN_MENU_CANCEL_menu_inc(UISm* sm)
{
    // MAIN_MENU_CANCEL behavior
    // uml: MENU_INC TransitionTo(MAIN_MENU_RF)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_RF`.
        MAIN_MENU_RF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CANCEL
    
    // No ancestor handles this event.
}

static void MAIN_MENU_CANCEL_select(UISm* sm)
{
    // MAIN_MENU_CANCEL behavior
    // uml: SELECT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CANCEL
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_CW
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_CW_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_CW;
}

static void MAIN_MENU_CW_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_CW_menu_dec(UISm* sm)
{
    // MAIN_MENU_CW behavior
    // uml: MENU_DEC TransitionTo(MAIN_MENU_AUDIO)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CW_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_AUDIO`.
        MAIN_MENU_AUDIO_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CW
    
    // No ancestor handles this event.
}

static void MAIN_MENU_CW_menu_inc(UISm* sm)
{
    // MAIN_MENU_CW behavior
    // uml: MENU_INC TransitionTo(MAIN_MENU_CALIBRATE)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_CW_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CALIBRATE`.
        MAIN_MENU_CALIBRATE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_CW
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MAIN_MENU_RF
////////////////////////////////////////////////////////////////////////////////

static void MAIN_MENU_RF_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_RF;
}

static void MAIN_MENU_RF_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_MAIN_MENU_DISPLAY;
}

static void MAIN_MENU_RF_menu_dec(UISm* sm)
{
    // MAIN_MENU_RF behavior
    // uml: MENU_DEC TransitionTo(MAIN_MENU_CANCEL)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_RF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_CANCEL`.
        MAIN_MENU_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_RF
    
    // No ancestor handles this event.
}

static void MAIN_MENU_RF_menu_inc(UISm* sm)
{
    // MAIN_MENU_RF behavior
    // uml: MENU_INC TransitionTo(MAIN_MENU_AUDIO)
    {
        // Step 1: Exit states until we reach `MAIN_MENU_DISPLAY` state (Least Common Ancestor for transition).
        MAIN_MENU_RF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MAIN_MENU_AUDIO`.
        MAIN_MENU_AUDIO_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for MAIN_MENU_RF
    
    // No ancestor handles this event.
}

static void MAIN_MENU_RF_select(UISm* sm)
{
    // MAIN_MENU_RF behavior
    // uml: SELECT TransitionTo(RF_MENU_DISPLAY)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_MENU_DISPLAY`.
        RF_MENU_DISPLAY_enter(sm);
        
        // RF_MENU_DISPLAY.<InitialState> behavior
        // uml: TransitionTo(RF_ADJUST_RX_GAIN)
        {
            // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `RF_ADJUST_RX_GAIN`.
            RF_ADJUST_RX_GAIN_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for RF_MENU_DISPLAY.<InitialState>
    } // end of behavior for MAIN_MENU_RF
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_MENU_DISPLAY
////////////////////////////////////////////////////////////////////////////////

static void RF_MENU_DISPLAY_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_MENU_DISPLAY_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_ADJUST_RX_GAIN
////////////////////////////////////////////////////////////////////////////////

static void RF_ADJUST_RX_GAIN_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_ADJUST_RX_GAIN;
}

static void RF_ADJUST_RX_GAIN_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_ADJUST_RX_GAIN_menu_dec(UISm* sm)
{
    // RF_ADJUST_RX_GAIN behavior
    // uml: MENU_DEC TransitionTo(RF_CANCEL)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_RX_GAIN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_CANCEL`.
        RF_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_RX_GAIN
    
    // No ancestor handles this event.
}

static void RF_ADJUST_RX_GAIN_menu_inc(UISm* sm)
{
    // RF_ADJUST_RX_GAIN behavior
    // uml: MENU_INC TransitionTo(RF_ADJUST_TX_GAIN)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_RX_GAIN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_TX_GAIN`.
        RF_ADJUST_TX_GAIN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_RX_GAIN
    
    // No ancestor handles this event.
}

static void RF_ADJUST_RX_GAIN_select(UISm* sm)
{
    // RF_ADJUST_RX_GAIN behavior
    // uml: SELECT / { uiUp = &uiRXGainUpdate; } TransitionTo(SHOW_VALUE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: `uiUp = &uiRXGainUpdate;`.
        sm->vars.uiUp = &uiRXGainUpdate;
        
        // Step 3: Enter/move towards transition target `SHOW_VALUE`.
        SHOW_VALUE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_RX_GAIN
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_ADJUST_SCALE
////////////////////////////////////////////////////////////////////////////////

static void RF_ADJUST_SCALE_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_ADJUST_SCALE;
}

static void RF_ADJUST_SCALE_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_ADJUST_SCALE_menu_dec(UISm* sm)
{
    // RF_ADJUST_SCALE behavior
    // uml: MENU_DEC TransitionTo(RF_SELECT_100WPA)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_SCALE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_SELECT_100WPA`.
        RF_SELECT_100WPA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_SCALE
    
    // No ancestor handles this event.
}

static void RF_ADJUST_SCALE_menu_inc(UISm* sm)
{
    // RF_ADJUST_SCALE behavior
    // uml: MENU_INC TransitionTo(RF_CANCEL)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_SCALE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_CANCEL`.
        RF_CANCEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_SCALE
    
    // No ancestor handles this event.
}

static void RF_ADJUST_SCALE_select(UISm* sm)
{
    // RF_ADJUST_SCALE behavior
    // uml: SELECT / { uiUp = &uiRFScaleUpdate; } TransitionTo(SHOW_VALUE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: `uiUp = &uiRFScaleUpdate;`.
        sm->vars.uiUp = &uiRFScaleUpdate;
        
        // Step 3: Enter/move towards transition target `SHOW_VALUE`.
        SHOW_VALUE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_SCALE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_ADJUST_TX_GAIN
////////////////////////////////////////////////////////////////////////////////

static void RF_ADJUST_TX_GAIN_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_ADJUST_TX_GAIN;
}

static void RF_ADJUST_TX_GAIN_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_ADJUST_TX_GAIN_menu_dec(UISm* sm)
{
    // RF_ADJUST_TX_GAIN behavior
    // uml: MENU_DEC TransitionTo(RF_ADJUST_RX_GAIN)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_TX_GAIN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_RX_GAIN`.
        RF_ADJUST_RX_GAIN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_TX_GAIN
    
    // No ancestor handles this event.
}

static void RF_ADJUST_TX_GAIN_menu_inc(UISm* sm)
{
    // RF_ADJUST_TX_GAIN behavior
    // uml: MENU_INC TransitionTo(RF_SELECT_100WPA)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_ADJUST_TX_GAIN_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_SELECT_100WPA`.
        RF_SELECT_100WPA_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_TX_GAIN
    
    // No ancestor handles this event.
}

static void RF_ADJUST_TX_GAIN_select(UISm* sm)
{
    // RF_ADJUST_TX_GAIN behavior
    // uml: SELECT / { uiUp = &uiTXGainUpdate; } TransitionTo(SHOW_VALUE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: `uiUp = &uiTXGainUpdate;`.
        sm->vars.uiUp = &uiTXGainUpdate;
        
        // Step 3: Enter/move towards transition target `SHOW_VALUE`.
        SHOW_VALUE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_ADJUST_TX_GAIN
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_CANCEL
////////////////////////////////////////////////////////////////////////////////

static void RF_CANCEL_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_CANCEL;
}

static void RF_CANCEL_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_CANCEL_menu_dec(UISm* sm)
{
    // RF_CANCEL behavior
    // uml: MENU_DEC TransitionTo(RF_ADJUST_SCALE)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_SCALE`.
        RF_ADJUST_SCALE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_CANCEL
    
    // No ancestor handles this event.
}

static void RF_CANCEL_menu_inc(UISm* sm)
{
    // RF_CANCEL behavior
    // uml: MENU_INC TransitionTo(RF_ADJUST_RX_GAIN)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_CANCEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_RX_GAIN`.
        RF_ADJUST_RX_GAIN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_CANCEL
    
    // No ancestor handles this event.
}

static void RF_CANCEL_select(UISm* sm)
{
    // RF_CANCEL behavior
    // uml: SELECT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, UISm_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_CANCEL
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state RF_SELECT_100WPA
////////////////////////////////////////////////////////////////////////////////

static void RF_SELECT_100WPA_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_SELECT_100WPA;
}

static void RF_SELECT_100WPA_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_RF_MENU_DISPLAY;
}

static void RF_SELECT_100WPA_menu_dec(UISm* sm)
{
    // RF_SELECT_100WPA behavior
    // uml: MENU_DEC TransitionTo(RF_ADJUST_TX_GAIN)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_SELECT_100WPA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_TX_GAIN`.
        RF_ADJUST_TX_GAIN_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_SELECT_100WPA
    
    // No ancestor handles this event.
}

static void RF_SELECT_100WPA_menu_inc(UISm* sm)
{
    // RF_SELECT_100WPA behavior
    // uml: MENU_INC TransitionTo(RF_ADJUST_SCALE)
    {
        // Step 1: Exit states until we reach `RF_MENU_DISPLAY` state (Least Common Ancestor for transition).
        RF_SELECT_100WPA_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `RF_ADJUST_SCALE`.
        RF_ADJUST_SCALE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for RF_SELECT_100WPA
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SHOW_VALUE
////////////////////////////////////////////////////////////////////////////////

static void SHOW_VALUE_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_SHOW_VALUE;
}

static void SHOW_VALUE_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}

static void SHOW_VALUE_menu_dec(UISm* sm)
{
    // SHOW_VALUE behavior
    // uml: MENU_DEC / { UIDecValue(); } TransitionTo(SHOW_VALUE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SHOW_VALUE_exit(sm);
        
        // Step 2: Transition action: `UIDecValue();`.
        UIDecValue();
        
        // Step 3: Enter/move towards transition target `SHOW_VALUE`.
        SHOW_VALUE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_VALUE
    
    // No ancestor handles this event.
}

static void SHOW_VALUE_menu_inc(UISm* sm)
{
    // SHOW_VALUE behavior
    // uml: MENU_INC / { UIIncValue(); } TransitionTo(SHOW_VALUE)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SHOW_VALUE_exit(sm);
        
        // Step 2: Transition action: `UIIncValue();`.
        UIIncValue();
        
        // Step 3: Enter/move towards transition target `SHOW_VALUE`.
        SHOW_VALUE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_VALUE
    
    // No ancestor handles this event.
}

static void SHOW_VALUE_select(UISm* sm)
{
    // SHOW_VALUE behavior
    // uml: SELECT TransitionTo(HOME)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SHOW_VALUE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SHOW_VALUE
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SPLASH
////////////////////////////////////////////////////////////////////////////////

static void SPLASH_enter(UISm* sm)
{
    sm->state_id = UISm_StateId_SPLASH;
    
    // SPLASH behavior
    // uml: enter / { splashCount_ms = 0; }
    {
        // Step 1: execute action `splashCount_ms = 0;`
        sm->vars.splashCount_ms = 0;
    } // end of behavior for SPLASH
}

static void SPLASH_exit(UISm* sm)
{
    sm->state_id = UISm_StateId_ROOT;
}

static void SPLASH_do(UISm* sm)
{
    // SPLASH behavior
    // uml: 1. do / { splashCount_ms++; }
    {
        // Step 1: execute action `splashCount_ms++;`
        sm->vars.splashCount_ms++;
    } // end of behavior for SPLASH
    
    // SPLASH behavior
    // uml: do [splashCount_ms >= splashDuration_ms] TransitionTo(HOME)
    if (sm->vars.splashCount_ms >= sm->vars.splashDuration_ms)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SPLASH_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `HOME`.
        HOME_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for SPLASH
    
    // No ancestor handles this event.
}

// Thread safe.
char const * UISm_state_id_to_string(UISm_StateId id)
{
    switch (id)
    {
        case UISm_StateId_ROOT: return "ROOT";
        case UISm_StateId_CALIBRATE_DISPLAYS: return "CALIBRATE_DISPLAYS";
        case UISm_StateId_CALIBRATE_CW_PA_DISPLAY: return "CALIBRATE_CW_PA_DISPLAY";
        case UISm_StateId_CALIBRATE_FREQUENCY_DISPLAY: return "CALIBRATE_FREQUENCY_DISPLAY";
        case UISm_StateId_CALIBRATE_RX_IQ_DISPLAY: return "CALIBRATE_RX_IQ_DISPLAY";
        case UISm_StateId_CALIBRATE_SSB_PA_DISPLAY: return "CALIBRATE_SSB_PA_DISPLAY";
        case UISm_StateId_CALIBRATE_TX_IQ_DISPLAY: return "CALIBRATE_TX_IQ_DISPLAY";
        case UISm_StateId_CALIBRATE_MENU_DISPLAY: return "CALIBRATE_MENU_DISPLAY";
        case UISm_StateId_CALIBRATE_CANCEL: return "CALIBRATE_CANCEL";
        case UISm_StateId_CALIBRATE_CW_PA: return "CALIBRATE_CW_PA";
        case UISm_StateId_CALIBRATE_FREQUENCY: return "CALIBRATE_FREQUENCY";
        case UISm_StateId_CALIBRATE_RX_IQ: return "CALIBRATE_RX_IQ";
        case UISm_StateId_CALIBRATE_SSB_PA: return "CALIBRATE_SSB_PA";
        case UISm_StateId_CALIBRATE_TX_IQ: return "CALIBRATE_TX_IQ";
        case UISm_StateId_HOME: return "HOME";
        case UISm_StateId_MAIN_MENU_DISPLAY: return "MAIN_MENU_DISPLAY";
        case UISm_StateId_MAIN_MENU_AUDIO: return "MAIN_MENU_AUDIO";
        case UISm_StateId_MAIN_MENU_CALIBRATE: return "MAIN_MENU_CALIBRATE";
        case UISm_StateId_MAIN_MENU_CANCEL: return "MAIN_MENU_CANCEL";
        case UISm_StateId_MAIN_MENU_CW: return "MAIN_MENU_CW";
        case UISm_StateId_MAIN_MENU_RF: return "MAIN_MENU_RF";
        case UISm_StateId_RF_MENU_DISPLAY: return "RF_MENU_DISPLAY";
        case UISm_StateId_RF_ADJUST_RX_GAIN: return "RF_ADJUST_RX_GAIN";
        case UISm_StateId_RF_ADJUST_SCALE: return "RF_ADJUST_SCALE";
        case UISm_StateId_RF_ADJUST_TX_GAIN: return "RF_ADJUST_TX_GAIN";
        case UISm_StateId_RF_CANCEL: return "RF_CANCEL";
        case UISm_StateId_RF_SELECT_100WPA: return "RF_SELECT_100WPA";
        case UISm_StateId_SHOW_VALUE: return "SHOW_VALUE";
        case UISm_StateId_SPLASH: return "SPLASH";
        default: return "?";
    }
}

// Thread safe.
char const * UISm_event_id_to_string(UISm_EventId id)
{
    switch (id)
    {
        case UISm_EventId_DO: return "DO";
        case UISm_EventId_MENU: return "MENU";
        case UISm_EventId_MENU_DEC: return "MENU_DEC";
        case UISm_EventId_MENU_INC: return "MENU_INC";
        case UISm_EventId_SELECT: return "SELECT";
        default: return "?";
    }
}
